\lstdefinestyle{proverif}{
    basicstyle=\footnotesize\sffamily,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keywordstyle=\color{ForestGreen}\textbf,
    commentstyle=\color{Gray}\textit,
    escapechar=\%,
    frame=tb,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    morekeywords={let, in, if, then, else, event, new, out, fun, reduc, forall, insert, get, table, type, free, const, process, sync},
    comment=[l]{(*}
}
\lstset{style=proverif}

\subsection{Supporting Constructs}

As noted in the previous section, \textsc{ProVerif} features a basic type system.
Aside from allowing for a closer representation of the actual protocol implementation, types also serve as guardrails while modelling the honest participants in that, for example, a constructor expecting an input of type bitstring cannot be called with a different type.
However, it should be noted that types are ignored by the adversary during verification stage, allowing \textsc{ProVerif} to detect potential type flaw attacks (c.f. \cite{blanchet2020proverif}, p. 38).

In addition to \textsc{ProVerif}'s built-in data types, a number of custom types displayed in listing~\ref{lst:types} are defined.
Compound data structures, such as {\sffamily aad}, {\sffamily prins}, {\sffamily modprins}, and {\sffamily ipxmod}, are defined solely for convenience and improved readability so as to not pass each of their respective subcomponents individually.
Other types are supposed to resemble data with specific characteristics.
A \gls{mac}, for example, is modelled by the type {\sffamily mac} that cannot be transformed back into its original components.
Data of type {\sffamily pubkey} on the other hand, can only be derived from a related {\sffamily privkey}.

\begin{lstlisting}[caption={Custom type definitions},label={lst:types},firstnumber=3]
type key.                           (* symmetric key *)
type mac.                           (* message authentication code *)
type http.                          (* http message *)
type privkey.                       (* asymmetric privat key *)
type pubkey.                        (* asymmetric public key *)
type prins.                         (* prins message *)
type modprins.                      (* modified prins message w/ patches *)
type aad.                           (* additional authenticated data *)
type ipxmod.                        (* json patch / ipx modifications *)
\end{lstlisting}

Listing~\ref{lst:channels} shows the defined channels used to transport messages between processes.
By default, channels follow the Dolev-Yao model, meaning that all information transferred over them can be read, modified, intercepted or arbitrarily created by the adversary.
Secure channels can be modelled by explicitly annotating them as private.

Three public channels are defined in order to represent the logical N32-f message flow from the sending \gls{sepp} to the first \gls{ipx} provider, from there to the next \gls{ipx} node, and finally to the receiving \gls{sepp}.
If all N32-f communication would use a single channel, the verification tool would have little information about the intended message flow involing multiple intermediaries.
A message sent by one \gls{sepp} could be received directly by another \gls{sepp} without ever traversing the \gls{ipx} nodes.
Beyond that, separate channels also alleviate the need to encode full-featured routing information in every single message, detailed further in section \ref{sec:issues}.

In contrast to N32-f, N32-c communication utilizes a single private channel.
Logically, this represents an end-to-end channel between two communicating \glspl{sepp} guaranteeing both confidentiality and integrity of messages.
As highlighted in section \ref{sec:goal}, proving security of established, well-tested protocols is considered out of scope.
Since the protection of N32-c traffic completely relies on \gls{tls}, the protocol is assumed to perfectly secure in that regard.

The two remaining channels {\sffamily err\_a} and {\sffamily err\_b} are used internally to the two participants, \gls{sepp}~A and \gls{sepp}~B, to pass information about errors in N32-f messages from the receiving N32-f process to the process handling error signaling via N32-c.

\begin{lstlisting}[caption={Custom channel declarations},label={lst:channels},firstnumber=15]
free n32f_a: channel.             (* Channel between SEPP A and IPX A *)
free n32f_i: channel.             (* Channel between IPX A and IPX B *)
free n32f_b: channel.             (* Channel between IPX B and SEPP B *)
free n32c: channel [private].     (* Channel between SEPP A and SEPP B *)
free err_a: channel [private].    (* Internal error signalling Sepp A *)
free err_b: channel [private].    (* Internal error signalling Sepp B *)
\end{lstlisting}

Listing~\ref{lst:constants} provides an overview of global constants used by the protocol model.
These are utilized at different points of the process execution to represent fixed, known values or flags.
An empty \gls{json} patch written by \gls{ipx} providers is modelled by the {\sffamily EMPTY} constant (see listing~\ref{lst:ipx-send}).
{\sffamily SEND} and {\sffamily RECV} flags are utilized during derivation of the N32-f keys to indicate whether or not the \gls{sepp} initiated the N32-c handshake (see listing~\ref{lst:n32c-handshake-send} and \ref{lst:n32c-handshake-recv}).
{\sffamily SUCC} and {\sffamily FAIL} are constants representing the status code for success or failure in error signaling procedures (see listing~\ref{lst:n32c-error-send} and \ref{lst:n32c-error-recv})

\begin{lstlisting}[caption={Global constant declarations},label={lst:constants},firstnumber=24]
const EMPTY: ipxmod.              (* the empty ipx patch *)
const SEND: bitstring.            (* sending flag *)
const RECV: bitstring.            (* receiving flag *)
const SUCC: bitstring.            (* success flag *)
const FAIL: bitstring.            (* failure flag *)
\end{lstlisting}

\textsc{ProVerif}'s tables are used to model each \gls{sepp}'s local storage for N32-f context information.
Each \gls{sepp} has to keep track of several attributes, listed in section \ref{sec:n32}, in order to correlate N32-f messages to a previously established session and check the validity of incoming messages.
The created model does not consider all of these information, abstracting away the following attributes cited in the \gls{3gpp} specification:
(1)~The remote \gls{sepp} ID, part of the N32-f peer information, is not considered.
In real-world implementations, this attribute helps peers to distinguish multiple \gls{sepp} instances in a foreign \gls{plmn}.
The model assumes there is only a single instance in each network.
(2)~The N32-f context information, which contains information about the validity (i.e. lifetime) of session keys and whether or not \gls{tls} shall be used to transport N32-f messages.
Firstly, the session key lifetime cannot be verified using formal methods, due to the lack of appropriate temporal constructs.
Secondly, it is assumed \gls{prins} is exclusively used to carry N32-f messages.

\begin{lstlisting}[caption={Declaration of local SEPP storage using tables},label={lst:tables},firstnumber=32]
table storeSeppA(
    bitstring,                    (* SEPP B PLMN ID *)
    bitstring,                    (* SEPP B Address *)
    bitstring,                    (* N32-f Context ID *)
    nat,                          (* N32-f Message Counter *)
    key,                          (* parallel request key *)
    key,                          (* reverse request key *)
    bitstring,                    (* parallel request IV *)
    bitstring,                    (* reverse request IV *)
    bitstring,                    (* JWE Ciphersuite *)
    bitstring,                    (* Data-type encryption policy *)
    bitstring,                    (* SEPP A modification policy *)
    bitstring,                    (* SEPP B modification policy *)
    bitstring,                    (* IPX A id *)
    pubkey,                       (* IPX A public key *)
    bitstring,                    (* IPX B id *)
    pubkey).                      (* IPX B public key *)
\end{lstlisting}

Data constructors are used to model type transformations in \textsc{ProVerif}.
Listing~\ref{lst:constructor} shows an example that combines the information elements added by intermediate \gls{ipx} providers when applying message modifications.
This particular constructor takes four information elements of type {\sffamily bitstring}, {\sffamily mac}, {\sffamily bitstring}, and {\sffamily bitstring} and produces a single {\sffamily ipxmod} element.
Fundamentally, this follows the same syntax as other \textsc{ProVerif} funtions.
However, the {\sffamily [data]} annotation has the effect that the adversary is able to deconstruct the resulting data type into its original subcomponents at any time (c.f. \cite{blanchet2020proverif}, p. 37).

\begin{lstlisting}[caption={Definition of custom data constructor},label={lst:constructor},firstnumber=75]
fun jsonPatch(bitstring,          (* Operations *)
    bitstring,                    (* IPX Id *)
    mac,                          (* JWE Tag *)
    bitstring): ipxmod [data].    (* JWS Signature *)
\end{lstlisting}

Listing~\ref{lst:functions} shows an example of custom functions being used in the \gls{prins} model.
By default, they are available to all protocol participants, incl. the adversary.
Below functions for the derivation of N32-f context ID, master key, session key, and \gls{aes} initialization vector are one-way functions.
Since there are no related deconstructors defined, the original function inputs cannot be derived from its output.

The function {\sffamily deriveMasterKey} is uniquely defined as a private function due to a limitation of the created model.
According to the \gls{3gpp} specification, the N32-f master key is derived from the N32-c session using \gls{tls} keying material exporters.
Since the \gls{tls} protocol is not modelled in detail, the {\sffamily deriveMasterKey} function is defined as a substitude that is not available to the Dolev-Yao adversary.
Section \ref{sec:issues} further describes the benefits and drawbacks of modelling the key derivation in this way.

\begin{lstlisting}[caption={Definition of custom one-way functions},label={lst:functions},firstnumber=96]
fun deriveContextId(bitstring, bitstring): bitstring.
fun deriveMasterKey(bitstring, nat): key [private].
fun deriveSessionKey(bitstring, key): key.
fun deriveIV(bitstring, key): bitstring.
\end{lstlisting}

In contrast to the functions displayed above, there are other constructors defined with one or more related deconstructors, reversing a particular operation.
This is examplified by the {\sffamily sign} function in listing~\ref{lst:destructors}.
Given two inputs of type {\sffamily bitstring} and {\sffamily privkey}, the function creates a new {\sffamily bitstring}, resembling a digital signature.
The related deconstructor {\sffamily checkSign} takes two arguments of type {\sffamily bitstring} and {\sffamily pubkey} and returns the original message.
This operation only succeeds with the public key belonging to the private key that was previously used for signing the message, i.e. if the signature is valid.
The second deconstructor depicted in the listing below is provided to allow the adversary to retrieve signed message contents without possessing the public key for validation, as suggested by the \textsc{ProVerif} authors themselves (c.f. \cite{blanchet2020proverif}, p. 14).

\begin{lstlisting}[caption={Definition of custom constructors and destructors},label={lst:destructors},firstnumber=112]
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey;
    checkSign(sign(m, k), pk(k)) = m.
reduc forall m: bitstring, k: privkey;
    getMess(sign(m, k)) = m.
\end{lstlisting}

\subsection{N32-c Processes}

According to the specification, N32-c communication comprises three different procedures: Key agreement, parameter exchange (e.g. protection policies or \gls{ipx} provider information), and error handling (c.f. \cite{3gpp.33.501}, p. 128).
The model created as part of this work combines the first two into a single procedure for initial session establishment and considers a separate error signaling procedure.
Each of them is defined by a sending and a receiving process.
Further, each process is modelled separately for \gls{sepp}~A and \gls{sepp}~B, since all processes access local storage, represented by a distinct table for each \gls{sepp} (see listing~\ref{lst:tables}).

Listing~\ref{lst:n32c-handshake-send} shows the sending process of the N32-c handshake for \gls{sepp}~A.
Initially, a fresh N32-f pre-context ID is created and sent towards the peer \gls{sepp} the N32-c channel, together with the configured cipher suites.
The following line shows that a similar information is expected from the other party as well, this time containing cipher suite agreed by both endpoints.
The process validates whether the target address maches its own \gls{sepp} address, only proceeding to create a final N32-f context ID from the two precontext IDs if this condition is met.
This check is necessary for every incoming message in order to ensure correct execution of the protocol flow.
Section \ref{sec:issues} explains this requirement in detail and what impact it has on the verification result.

Subsequently, the \glspl{sepp} exchange encryption policy and modification policy.
The information is accompanied by the target \gls{sepp} address and the N32-f context ID agreed during the previous step.
Again, the process only continues if the incoming message contains the correct target address, N32-f context ID and an encryption policy that matches its own.
Recall that the \gls{3gpp} specification assumes these protection policies to be agreed by the \gls{sepp} operators in advance (see section \ref{sec:n32}).
Following a successful protecion policy exchange, the \gls{ipx} security information lists are shared, i.e. an identifier of each \gls{sepp}'s directly connected \gls{ipx} provider and its public key.

Subsequently, the master key is derived using the above-mentioned constructor {\sffamily deriveMasterKey} and the session's message counter, initialized with the value 0.
The message counter is chosen as an input parameter for this private function, since it guarantees a different output and thus, the creation of a new key when the key is refreshed after each N32-f message exchange.
If no input would be provided whatsoever, the function would produce the same value every time.
Based on this master key, further session keys and initialization vectors are derived which are used in the N32-f \gls{aead} operations.
Since the protocol distinguishes session keys and initialization vectors to be used based on the \gls{sepp}'s role in the N32-c communication, the functions {\sffamily deriveSessionKey} and {\sffamily deriveIV} consume a flag indicating whether the \gls{sepp} initiated the N32-c session ({\sffamily SEND}) or not ({\sffamily RECV}), in addition to the master key.
Lastly, the agreed session parameters are stored in the \gls{sepp}'s local storage table.

\begin{lstlisting}[caption={Definition of the sending N32-c handshake process},label={lst:n32c-handshake-send},firstnumber=307]
let N32cSendHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    in(n32c, (
        sepp_a_addr': bitstring, ciphers_b: bitstring, n32f_pid_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr then
    let n32f_cid = deriveContextId(n32f_pid, n32f_pid_b) in
    event sentN32fContextSeppA(n32f_cid);

    (* verify matching encryption policies *)
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));
    in(n32c, (sepp_a_addr': bitstring, n32f_cid': bitstring,
        encp_b: bitstring, modp_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr &&
        n32f_cid' = n32f_cid &&
        encp_b = encp_a then
    event agreedEncPolicySend(sepp_a_addr, n32f_cid, encp_a);

    (* exchange ipx information *)
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));
    in(n32c, (
        sepp_a_addr': bitstring, n32f_cid': bitstring, ipx_b_id: bitstring,
        ipx_b_key: pubkey
    ));

    (* key derivation *)
    if sepp_a_addr' = sepp_a_addr && n32f_cid' = n32f_cid then
    let msg_cnt = 0 in
    let master_key_a = deriveMasterKey(n32f_cid, msg_cnt) in
    event sentMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_key_a = deriveSessionKey(SEND, master_key_a) in
    let rev_key_a = deriveSessionKey(RECV, master_key_a) in
    let par_iv_a = deriveIV(SEND, master_key_a) in
    let rev_iv_a = deriveIV(RECV, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt, par_key_a, rev_key_a,
        par_iv_a, rev_iv_a, ciphers_a, encp_a, modp_a, modp_b, ipx_a_id,
        ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

The receiving N32-c handshake process is structured similarly, with a few key distinctions (see listing~\ref{lst:n32c-handshake-recv}).
Firstly, the \gls{sepp} creates a fresh N32-f precontext ID.
Secondly, \gls{sepp} address, cipher suites, and N32-f precontext ID are received from the \gls{sepp} initiating the communication.
If the address of the receiving \gls{sepp} and the cipher suites match, the \gls{sepp} responds with its own N32-f precontext ID and the agreed cipher suite.
The final N32-f context ID is derived in the same way as by the sending \gls{sepp}.

Subsequently, the protecion policies are exchanged.
As is the case in the sending process, the receiving party of the N32-c handshake only progresses if the N32-f context ID and the configured encryption policies in both \glspl{sepp} are the same.
This step is again followed by the exchange of information related to the involved \gls{ipx} providers.

The parameter exchanges are followed by the derivation of master key, session keys and initialization vectors.
The only difference to the sending N32-c handshake process is the flags used for creation of the session keys.
In the listing below, the parallel session key and \gls{iv} are derived with the constant parameter {\sffamily RECV}, since the \gls{sepp} is on the receiving end of the initial N32-c handshake.
In contrast, the function {\sffamily deriveSessionKey} uses parameter {\sffamily SEND} for the reverse session key in initialization vector.
Lastly, all session parameters are stored in the \gls{sepp}'s local storage.

\begin{lstlisting}[caption={Definition of the receiving N32-c handshake process},label={lst:n32c-handshake-recv},firstnumber=356]
let N32cRecvHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    in(n32c, (
        sepp_a_addr': bitstring, ciphers_b: bitstring, n32f_pid_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr && ciphers_a = ciphers_b then
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    let n32f_cid = deriveContextId(n32f_pid_b, n32f_pid) in
    event recvN32fContextSeppA(n32f_cid);

    (* verify matching encryption policies *)
    in(n32c, (sepp_a_addr': bitstring, n32f_cid': bitstring,
        encp_b: bitstring, modp_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr &&
        n32f_cid' = n32f_cid &&
        encp_b = encp_a then
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));
    event agreedEncPolicyRecv(sepp_a_addr, n32f_cid, encp_a);

    (* exchange ipx information *)
    in(n32c, (sepp_a_addr': bitstring, n32f_cid': bitstring,
        ipx_b_id: bitstring, ipx_b_key: pubkey
    ));
    if sepp_a_addr' = sepp_a_addr && n32f_cid' = n32f_cid then
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));

    (* key derivation *)
    if sepp_a_addr' = sepp_a_addr && n32f_cid' = n32f_cid then
    let msg_cnt = 0 in
    let master_key_a = deriveMasterKey(n32f_cid, msg_cnt) in
    event recvMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_key_a = deriveSessionKey(RECV, master_key_a) in
    let rev_key_a = deriveSessionKey(SEND, master_key_a) in
    let par_iv_a = deriveIV(RECV, master_key_a) in
    let rev_iv_a = deriveIV(SEND, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt, par_key_a, rev_key_a,
        par_iv_a, rev_iv_a, ciphers_a, encp_a, modp_a, modp_b, ipx_a_id,
        ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

Listing~\ref{lst:n32c-error-send} shows the sending \gls{sepp}'s part of error signaling process carried out over N32-c, the details of which are described not in the security specification \gls{ts} 33.501, but \gls{ts} 33.573 (c.f. \cite{3gpp.29.573}, p. 18).

After detecting an error in an incoming N32-f message, modelled by receiving a message containing on the internal channel {\sffamily err\_a}, the \gls{sepp} retrieves the related N32-f context from its local storage.
Based on this information, the process initiates an error signaling message over the N32-c channel, containing the target \gls{sepp}'s address, the N32-f context ID, and the identifier of the flawed message received.

The \gls{sepp} then awaits a respone from its peer, confirming the receipt of the error message and informing the sending \gls{sepp} about the result of the error signaling.
How the contents of this response are determined is shown in the next listing~\ref{lst:n32c-error-recv}.

\begin{lstlisting}[caption={Definition of the sending error signaling process},label={lst:n32c-error-send},firstnumber=406]
let N32cSendErrorSeppA(sepp_a_addr: bitstring)=
    in(err_a, (n32f_context': bitstring, msg_id: nat));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt, par_key_a,
        rev_key_a, par_iv_a, rev_iv_a, ciphers_a, encp_a, modp_a,
        modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send error notification *)
    out(n32c, (sepp_b_addr, n32f_context, msg_id));

    (* receive confirmation *)
    in(n32c, (
        sepp_a_addr': bitstring, n32f_context': bitstring, msg_id': nat,
        status_code: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr &&
        n32f_context' = n32f_context &&
        msg_id' = msg_id then
    event errorSignalingSend(sepp_a_addr, n32f_context, msg_id, status_code).
\end{lstlisting}

Listing~\ref{lst:n32c-error-recv} contains the receiving part of the error signaling procedure.
After receiving an error signaling message from its peer on N32-c, the \gls{sepp} retrieves the locally stored session parameters, based on the N32-f context ID.

The \gls{sepp} performs a validation of the received message ID, checking whether it is lower than or equal to the locally maintained message counter.
This ensures a previous message with the same id has been sent.
A confirmation message including a status code is signaled back to the peer \gls{sepp} over N32-c.
If above-mentioned check was successful, this status code is the constant {\sffamily SUCC}, else {\sffamily FAIL}.

\begin{lstlisting}[caption={Definition of the receiving error signaling process},label={lst:n32c-error-recv},firstnumber=427]
let N32cRecvErrorSeppA(sepp_a_addr: bitstring)=
    in(n32c, (
        sepp_a_addr': bitstring, n32f_context': bitstring, msg_id: nat
    ));
    if sepp_a_addr' = sepp_a_addr then
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt, par_key_a,
        rev_key_a, par_iv_a, rev_iv_a, ciphers_a, encp_a, modp_a,
        modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send confirmation *)
    if msg_id <= msg_cnt then
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, SUCC));
        event errorSignalingRecv(sepp_a_addr, n32f_context, msg_id, SUCC)
    )
    else
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, FAIL));
        event errorSignalingRecv(sepp_a_addr, n32f_context, msg_id, FAIL)
    ).
\end{lstlisting}

\subsection{N32-f Processes}

Listing~\ref{lst:n32f-send} shows the sending N32-f process, i.e. the process in which signaling data is actually transferred.
For the purpose of formal verification, the exact contents of said signaling messages do are of no concern.
Hence, the sending \gls{sepp} initial creates a fresh messages of type {\sffamily http}.
In real-world deployments, this message would be received from a \gls{nf} in the \gls{sepp}'s own \gls{plmn}.
After retrieving the session context for the target \gls{sepp}, said \gls{http} message is split into a confidential and non-confidential part using the {\sffamily reformatHttp} deconstructor and the data-type encryption policy.

Next, the message is assigned a unique identifier by incrementing the locally maintained message counter.
All information used as \gls{aad} is combined into a single structure before being put into the \gls{aead} encryption function.
The encryption function uses the parallel session key, the parallel initialization vector, the confidential part of the signaling message, and the \gls{aad} to produce the encrypted message content ({\sffamily payload}) and a \gls{jwe} tag required for authentication.
These information are combined with further supplementary information as shown in figure \ref{fig:n32f-message} and then sent towards the peer \gls{sepp} over the public N32-f channel.

Lastly, the local N32-f context is updated to reflect the incremented message counter.

\begin{lstlisting}[caption={Definition of the sending N32-f signaling transmission process},label={lst:n32f-send},firstnumber=595]
let N32fSendSeppA(sepp_b_addr: bitstring)=
    new msg: http;
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr', n32f_context, msg_cnt_a, par_key_a,
        rev_key_a, par_iv_a, rev_iv_a, cipher_suite, encp, modp_a,
        modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat sepp_b_addr' = sepp_b_addr in
    let (conf: bitstring, nonconf: bitstring) = reformatHttp(msg, encp) in
    let msg_id: nat = msg_cnt_a + 1 in
    let associated_data = combineAAD(
        nonconf, msg_id, ipx_a_id, n32f_context
    ) in
    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        par_key_a,
        par_iv_a,
        conf,
        associated_data
    ) in
    out(n32f_a, (sepp_b_addr, prins'(
        cipher_suite, par_iv_a, associated_data, payload, jwe_tag
    )));
    event sendN32fMsgSeppA(n32f_context, conf, nonconf);
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr', n32f_context, msg_id, par_key_a,
        rev_key_a, par_iv_a, rev_iv_a, cipher_suite, encp, modp_a,
        modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

The receiving part of N32-f signaling is modelled by the process in listing~\ref{lst:n32f-recv}.
The \gls{sepp} initially receives a modified \gls{prins} message.
Note, that even if none of the intermediate \gls{ipx} providers is required to make changes to a N32-f message, they are still be expected to each create an empty \gls{json} patch and sign it - hence the data type {\sffamily modprins}.

Next, the received message is decomposed into parts written by the sending \gls{sepp} and the two added patches.
The \gls{aad} object is further broken down to access non-confidential parts of the original message as well as the N32-f message ID, the identity of the authorized \gls{ipx}, and the related N32-f context.
The latter is required to look-up the matching session context in local storage in lines 646-650.
The following \gls{aead} decryption operation, if successful, yields the encrypted part of the original N32-f signaling message.

Afterwards, the first \gls{json} patch is validated by checking the validity of the \gls{jws} object, whether its origin is the same as specified by the sending \gls{sepp} in parameter {\sffamily auth\_ipx\_id}, by ensuring the operations are part of the modification policy, and by validating the contained \gls{jwe} tag is the same as the one in the original message.
If all four checks pass successfully, the patch is considered valid, else invalid, and an appropriate flag is set.
The modification of the patch by the second \gls{ipx} provider is omitted in the listing below for brevity.
Validation happens in the exact same way with one minor deviation: Instead of validating the source of the \gls{json} patch against the authorized \gls{ipx} identifier specified by the sending \gls{sepp}, it is compared against the identifier of the second \gls{ipx} provider on the path, which is locally stored in the N32-f context.
Lastly, if both \gls{json} patch validations succeed, the message as a whole is considered valid.
Any subsequent actions, such as reformatting the N32-f message to an \gls{http} message while applying the two patches, are not considered in the model.

\lstset{escapeinside=~~}
\begin{lstlisting}[caption={Definition of the receiving N32-f signaling transmission process},label={lst:n32f-recv},firstnumber=623]
let N32fRecvSeppA(sepp_a_addr: bitstring)=
    in(n32f_a, (sepp_a_addr': bitstring, prins_messsage: modprins));
    if sepp_a_addr' = sepp_a_addr then

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        rev_iv_a': bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id: bitstring,
        n32f_context': bitstring
    ) = dataToIntegrityProtect in

    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_key_a,
        rev_key_a, par_iv_a, rev_iv_a, cipher_suite, encp, modp_a,
        modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    let conf = aeadDecrypt(
        rev_key_a,
        rev_iv_a,
        (dataToIntegrityProtectAndCipher, jwe_tag),
        dataToIntegrityProtect
    ) in

    (* verify ipx b json patch *)
    let jsonPatch(
        ipx_b_ops: bitstring,
        ipx_b_id': bitstring,
        jwe_tag_b: mac,
        ipx_b_jws: bitstring
    ) = ipx_b_mods in
    if checkPrinsSign(ipx_b_jws, ipx_b_key) &&
        auth_ipx_id = ipx_b_id' &&
        ipx_b_ops = modp_b &&
        jwe_tag_b = jwe_tag
    then
    (
        let valid_patch_b: bool = true in
        event recvValidIpxPatch(
            sepp_a_addr, auth_ipx_id, n32f_context, jwe_tag, ipx_b_mods
        )
    )
    else
        let valid_patch_b: bool = false in
        out(err_a, (n32f_context, msg_id));
    ~\Suppressnumber~

    (* validation of second patch omitted *)
    ~\Reactivatenumber{703}~
    (* all patches valid *)
    if valid_patch_a && valid_patch_b then
    event recvN32fMsg(sepp_a_addr, n32f_context, conf, nonconf).
\end{lstlisting}

\subsection{IPX Processes}

As with the \glspl{sepp}, the two directly connected intermediaries providers are modelled separately as \gls{ipx} A and \gls{ipx} B.
Listing~\ref{lst:ipx-send} shows the process of \gls{ipx} A receiving a message from its peer \gls{sepp}, applying the first \gls{json} patch and then sending it on to the next \gls{ipx} provider.

After receiving the N32-f message, it is decomposed into its individual parts.
This operation, among other information, yields the \gls{jwe} tag required for writing legitimate message modifications.
Lines 838-840 show how the message operations (i.e. the modifications itself), the \gls{ipx} provider ID, the \gls{jwe} tag, and a \gls{jws} signature of the complete message are combined to form this patch.

The following decomposition of the \gls{aad} object solely serves the purpose of accessing the N32-f context ID and the message ID used by event {\sffamily ipxSendA} at the end of the process.
Section \ref{sec:analysis} describes how this information is used for verification.
Afterwards, the \gls{ipx} provider's patch is combined with the original message contents in lines 851-859 to form a modified \gls{prins} message of type {\sffamily modprins}.
Note, that there is an additional, empty \gls{json} patch written by this first \gls{ipx} provider.
This is done to simplify the model by not creating a separate data-type for a modified \gls{prins} message with a single \gls{json} patch.
Finally, the modified message is sent towards the next \gls{ipx} provider.

\begin{lstlisting}[caption={Definition of the sending IPX process},label={lst:ipx-send},firstnumber=825]
let N32fSendIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_a, (sepp_b_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    out(n32f_i, (sepp_b_addr, modified_message));
    event ipxSendA(n32f_context, jwe_tag, modifications).
\end{lstlisting}

Listing~\ref{lst:ipx-recv} shows the process of \gls{ipx} A receiving a N32-f message from the \gls{ipx} network that is to be forwarded to its directly connected \gls{sepp}.
The actions performed are largely the same as in the sending process above, the difference being that this time, an already modified \gls{prins} message is received on the interface between \gls{ipx} providers.
Further, the empty \gls{json} patch inserted by the previous \gls{ipx} provider is replaced before forwarding the updated message to the receiving \gls{sepp}.

\begin{lstlisting}[caption={Definition of the receiving IPX process},label={lst:ipx-recv},firstnumber=863]
let N32fRecvIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        EMPTY: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    out(n32f_a, (sepp_a_addr, modified_message));
    event ipxRecvA(n32f_context, jwe_tag, modifications).
\end{lstlisting}

\subsection{Main process}

Listing~\ref{lst:main-proc} shows how the main process of the \textsc{ProVerif} model is defined.
This is where the previously described processes are combined in a way that models the overall protocol flow.
For brevity, the definition of variables, such as idientifiers for \gls{sepp} and \gls{ipx} nodes, cryptographic keys, and protection policies, have been omitted.

The execution is structured into two separate phases using {\sffamily sync}.
As noted in section~\ref{sec:formal}, \textsc{ProVerif} synchronization points ensure that processes are executed in a particular order -- according to the integer specified behind the {\sffamily sync} keyword.
Beyond that, all individual processes are combined using the pipe operator ,,~{\sffamily |}~'', denoting parallel execution.
Hence, processes in one synchronization group will be run together and have to terminate successfully before the process continues with the next synchronization group.
Processes are not forcefully terminated preemptively.
Each process is denoted with a preceeding exclamation mark operator ,,~{\sffamily !}~''.
This tells \textsc{ProVerif} that multiple instances of a process shall be spawned.
By doing so, the tool is able to check for potential security flaws due to confusion of N32 sessions by any of the legitimate participants.

By default, processes that are not specifically marked run in synchronization group~0.
In the created \gls{prins} model this group comprises all N32-c processes of the two communicating \glspl{sepp}.
Both attempt to initiate multiple N32-c sessions in parallel and are also listening to multiple incoming requests.
Information passed to these processes include \gls{plmn} IDs, \gls{sepp} addresses as well as the session parameters ciphersuites, protection policies and \gls{ipx} provider information.
All of these information are expected to be preconfigured and remain unchanged in communication with one peer \gls{sepp} over one particular \gls{ipx} provider.

Synchronization group~1 contains the complete set of processes relevant during \mbox{N32-f} communication.
That is, processes of sending and receiving \glspl{sepp}, error signalling processes in case a flaw is detected by one of the \glspl{sepp} as well as both directly connected \gls{ipx} providers.
Similar to the preceeding synchronization group, multiple process instances are executed in parallel to test for accidental session mix-ups.

The sending N32-f processes {\sffamily N32fSendSeppA} and {\sffamily N32fSendSeppB} each consume the address of the peer a message should be sent to.
The receiving process on the other hand, such as {\sffamily N32fRecvSeppA}, expects to receive it's own \gls{sepp} address in order to validate the target address of incoming messages against it.
The same applies to both of the error signaling processes of each \gls{sepp}.
Since the initiating end (e.g. {\sffamily N32cSendErrorSeppA}) as well as the responding end (e.g. {\sffamily N32cRecvErrorSeppA}) receive messages on N32-c, they require their own \gls{sepp} address for validating them.

As far as the \gls{ipx} providers are concerned, the information passed to these processes are the \gls{ipx} identifiers, the private key used to sign N32-f message modifications, and the list of legitimate modifications, i.e. the modification policy, defined by the \gls{mno} the \gls{ipx} provider has a direct relation with.
The model assumes that this information has been exchanged between the parties previously and thus, is provided directly to the \gls{ipx} processes.
Lines 1209-1212 show that the model also includes two rouge \gls{ipx} providers, {\sffamily R1} and {\sffamily R2}, that are intentionally violating the protocol.
Chapter \ref{chap:verification} further explains how these processes are used to verify security properties of \gls{prins}.

\begin{lstlisting}[caption={Definition of the main process},label={lst:main-proc},firstnumber=1183]
    (* process execution *)
    (
        (!N32cSendHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
        (!N32cRecvHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
        (!N32cSendHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (!N32cRecvHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (sync 1; !N32fSendSeppA(sepp_b_addr)) |
        (sync 1; !N32fSendSeppB(sepp_a_addr)) |
        (sync 1; !N32fRecvSeppA(sepp_a_addr)) |
        (sync 1; !N32fRecvSeppB(sepp_b_addr)) |
        (sync 1; !N32cSendErrorSeppA(sepp_a_addr)) |
        (sync 1; !N32cRecvErrorSeppA(sepp_a_addr)) |
        (sync 1; !N32cSendErrorSeppB(sepp_b_addr)) |
        (sync 1; !N32cRecvErrorSeppB(sepp_b_addr)) |
        (sync 1; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 1; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 1; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 1; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 1; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 1; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
        (sync 1; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 1; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a))
    )
\end{lstlisting}