\lstdefinestyle{proverif}{
    basicstyle=\footnotesize\sffamily,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keywordstyle=\color{ForestGreen}\textbf,
    commentstyle=\color{Gray}\textit,
    escapechar=\%,
    frame=tb,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    morekeywords={let, in, if, then, else, event, new, out, fun, reduc, forall, insert, get, table, type, free, const, process, sync},
    comment=[l]{(*}
}
\lstset{style=proverif}

\subsection{Supporting Constructs}

As noted in the previous section, \textsc{ProVerif} features a basic type system.
Aside from allowing for a closer representation of the actual protocol implementation, types also serve as guardrails while modelling the honest participants in that, for example, a constructor expecting an input of type bitstring cannot be called with a different type.
However, it should be noted that types are ignored by the adversary during verification stage, allowing \textsc{ProVerif} to detect potential type flaw attacks (c.f. \cite{blanchet2020proverif}, p. 38).

In addition to \textsc{ProVerif}'s built-in data types, a number of custom types displayed in listing~\ref{lst:types} are defined.
Compound data structures, such as {\sffamily aad}, {\sffamily prins}, {\sffamily modprins}, and {\sffamily ipxmod}, are defined solely for convenience and improved readability so as to not pass each of their respective subcomponents individually.
Other types are supposed to resemble data with specific characteristics.
A \gls{mac}, for example, is modelled by the type {\sffamily mac} that cannot be transformed back into its original components.
Data of type {\sffamily pubkey} on the other hand, can only be derived from a related {\sffamily privkey}.

\begin{lstlisting}[caption={Custom type definitions},label={lst:types},firstnumber=3]
type key.                           (* symmetric key *)
type mac.                           (* message authentication code *)
type http.                          (* http message *)
type privkey.                       (* asymmetric privat key *)
type pubkey.                        (* asymmetric public key *)
type prins.                         (* prins message *)
type modprins.                      (* modified prins message w/ patches *)
type aad.                           (* additional authenticated data *)
type ipxmod.                        (* ipx json patch *)
\end{lstlisting}

Listing~\ref{lst:channels} shows the defined channels used to transport messages between processes.
By default, channels follow the Dolev-Yao model, meaning that all information transferred over them can be read, modified, intercepted or arbitrarily created by the adversary.
Secure channels can be modelled by explicitly annotating them as private.

Three public channels are defined in order to represent the logical N32-f message flow from the sending \gls{sepp} to the first \gls{ipx} provider, from there to the next \gls{ipx} node, and finally to the receiving \gls{sepp}.
If all N32-f communication would use a single channel, the verification tool would have little information about the intended message flow involing multiple intermediaries.
A message sent by one \gls{sepp} could be received directly by another \gls{sepp} without ever traversing the \gls{ipx} nodes.
Beyond that, separate channels also alleviate the need to encode full-featured routing information in every single message, detailed further in section \ref{sec:issues}.

In contrast to N32-f, N32-c communication utilizes a single private channel.
Logically, this represents an end-to-end channel between two communicating \glspl{sepp} guaranteeing both confidentiality and integrity of messages.
As highlighted in section \ref{sec:goal}, proving security of established, well-tested protocols is considered out of scope.
Since the protection of N32-c traffic completely relies on \gls{tls}, the protocol is assumed to perfectly secure in that regard.

The two remaining channels {\sffamily err\_a} and {\sffamily err\_b} are used internally to the two participants, \gls{sepp}~A and \gls{sepp}~B, to pass information about errors in N32-f messages from the receiving N32-f process to the process handling error signaling via N32-c.

\begin{lstlisting}[caption={Custom channel declarations},label={lst:channels},firstnumber=15]
free plmn_a: channel [private].     (* PLMN A internal channel *)
free plmn_b: channel [private].     (* PLMN B internal channel *)
free n32f_a: channel.               (* Channel between SEPP A and IPX A *)
free n32f_i: channel.               (* Channel between IPX Providers *)
free n32f_b: channel.               (* Channel between IPX B and SEPP B *)
free n32c: channel [private].       (* Channel between SEPP A and SEPP B *)
free err_a: channel [private].      (* Internal error signalling Sepp A *)
free err_b: channel [private].      (* Internal error signalling Sepp B *)
\end{lstlisting}

Listing~\ref{lst:constants} provides an overview of global constants used by the protocol model.
These are utilized at different points of the process execution to represent fixed, known values or flags.
An empty \gls{json} patch written by \gls{ipx} providers is modelled by the {\sffamily EMPTY} constant (see listing~\ref{lst:ipx-send}).
{\sffamily SEND} and {\sffamily RECV} flags are utilized during derivation of the N32-f keys to indicate whether or not the \gls{sepp} initiated the N32-c handshake (see listing~\ref{lst:n32c-handshake-send} and \ref{lst:n32c-handshake-recv}).
{\sffamily SUCC} and {\sffamily FAIL} are constants representing the status code for success or failure in error signaling procedures (see listing~\ref{lst:n32c-error-send} and \ref{lst:n32c-error-recv})

\begin{lstlisting}[caption={Global constant declarations},label={lst:constants},firstnumber=24]
const EMPTY: ipxmod.                (* the empty ipx patch *)
const SUCC: bitstring.              (* success flag *)
const FAIL: bitstring.              (* failure flag *)
const SEND: bitstring.              (* sending flag *)
const RECV: bitstring.              (* receiving flag *)
const REQ: bitstring.               (* HTTP Request *)
const RES: bitstring.               (* HTTP Response *)
\end{lstlisting}

\textsc{ProVerif}'s tables are used to model each \gls{sepp}'s local storage for N32-f context information.
Each \gls{sepp} has to keep track of several attributes, listed in section \ref{sec:n32}, in order to correlate N32-f messages to a previously established session and check the validity of incoming messages.
The created model does not consider all of these information, abstracting away the following attributes cited in the \gls{3gpp} specification:
(1)~The remote \gls{sepp} ID, part of the N32-f peer information, is not considered.
In real-world implementations, this attribute helps peers to distinguish multiple \gls{sepp} instances in a foreign \gls{plmn}.
The model assumes there is only a single instance in each network.
(2)~The N32-f context information, which contains information about the validity (i.e. lifetime) of session keys and whether or not \gls{tls} shall be used to transport N32-f messages.
Firstly, the session key lifetime cannot be verified using formal methods, due to the lack of appropriate temporal constructs.
Secondly, it is assumed \gls{prins} is exclusively used to carry N32-f messages.

\begin{lstlisting}[caption={Declaration of local SEPP storage using tables},label={lst:tables},firstnumber=32]
table storeSeppA(
    bitstring,                      (* SEPP B PLMN ID *)
    bitstring,                      (* SEPP B Address *)
    bitstring,                      (* N32-f Context ID *)
    nat,                            (* N32-f Message Counter *)
    key,                            (* parallel request key *)
    key,                            (* parallel response key *)
    key,                            (* reverse request key *)
    key,                            (* reverse response key *)
    bitstring,                      (* parallel request IV *)
    bitstring,                      (* parallel response IV *)
    bitstring,                      (* reverse request IV *)
    bitstring,                      (* reverse response IV *)
    bitstring,                      (* JWE Ciphersuite *)
    bitstring,                      (* Data-type encryption policy *)
    bitstring,                      (* SEPP A modification policy *)
    bitstring,                      (* SEPP B modification policy *)
    bitstring,                      (* IPX A id *)
    pubkey,                         (* IPX A public key *)
    bitstring,                      (* IPX B id *)
    pubkey).                        (* IPX B public key *)
\end{lstlisting}

Data constructors are used to model type transformations in \textsc{ProVerif}.
Listing~\ref{lst:constructor} shows an example that combines the information elements added by intermediate \gls{ipx} providers when applying message modifications.
This particular constructor takes four information elements of type {\sffamily bitstring}, {\sffamily mac}, {\sffamily bitstring}, and {\sffamily bitstring} and produces a single {\sffamily ipxmod} element.
Fundamentally, this follows the same syntax as other \textsc{ProVerif} funtions.
However, the {\sffamily [data]} annotation has the effect that the adversary is able to deconstruct the resulting data type into its original subcomponents at any time (c.f. \cite{blanchet2020proverif}, p. 37).

\begin{lstlisting}[caption={Definition of custom data constructor},label={lst:constructor},firstnumber=75]
fun jsonPatch(bitstring,            (* Operations *)
    bitstring,                      (* IPX Id *)
    mac,                            (* JWE Tag *)
    bitstring): ipxmod [data].      (* JWS Signature *)
\end{lstlisting}

Listing~\ref{lst:functions} shows an example of custom functions being used in the \gls{prins} model.
By default, they are available to all protocol participants, incl. the adversary.
Below functions for the derivation of N32-f context ID, master key, session key, and \gls{aes} initialization vector are one-way functions.
Since there are no related deconstructors defined, the original function inputs cannot be derived from its output.

The function {\sffamily deriveMasterKey} is uniquely defined as a private function due to a limitation of the created model.
According to the \gls{3gpp} specification, the N32-f master key is derived from the N32-c session using \gls{tls} keying material exporters.
Since the \gls{tls} protocol is not modelled in detail, the {\sffamily deriveMasterKey} function is defined as a substitude that is not available to the Dolev-Yao adversary.
Section \ref{sec:issues} further describes the benefits and drawbacks of modelling the key derivation in this way.

\begin{lstlisting}[caption={Definition of custom one-way functions},label={lst:functions},firstnumber=96]
fun deriveContextId(bitstring, bitstring): bitstring.
fun deriveMasterKey(bitstring): key [private].
fun deriveSessionKey(bitstring, bitstring, key): key.
fun deriveIV(bitstring, bitstring, key): bitstring.
fun deriveNonce(bitstring, nat): bitstring.
fun applyPatches(bitstring, bitstring, bitstring): bitstring.
\end{lstlisting}

In contrast to the functions displayed above, there are other constructors defined with one or more related deconstructors, reversing a particular operation.
This is examplified by the {\sffamily sign} function in listing~\ref{lst:destructors}.
Given two inputs of type {\sffamily bitstring} and {\sffamily privkey}, the function creates a new {\sffamily bitstring}, resembling a digital signature.
The related deconstructor {\sffamily checkSign} takes two arguments of type {\sffamily bitstring} and {\sffamily pubkey} and returns the original message.
This operation only succeeds with the public key belonging to the private key that was previously used for signing the message, i.e. if the signature is valid.
The second deconstructor depicted in the listing below is provided to allow the adversary to retrieve signed message contents without possessing the public key for validation, as suggested by the \textsc{ProVerif} authors themselves (c.f. \cite{blanchet2020proverif}, p. 14).

\begin{lstlisting}[caption={Definition of custom constructors and destructors},label={lst:destructors},firstnumber=112]
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey;
    checkSign(sign(m, k), pk(k)) = m.
reduc forall m: bitstring, k: privkey;
    getMess(sign(m, k)) = m.
\end{lstlisting}

\subsection{N32-c Processes}

According to the specification, N32-c communication comprises three different procedures: Key agreement, parameter exchange (e.g. protection policies or \gls{ipx} provider information), and error handling (c.f. \cite{3gpp.33.501}, p. 128).
The model created as part of this work combines the first two into a single procedure for initial session establishment and considers a separate error signaling procedure.
Each of them is defined by a sending and a receiving process.
Further, each process is modelled separately for \gls{sepp}~A and \gls{sepp}~B, since all processes access local storage, represented by a distinct table for each \gls{sepp} (see listing~\ref{lst:tables}).

Listing~\ref{lst:n32c-handshake-send} shows the sending process of the N32-c handshake for \gls{sepp}~A.
Initially, a fresh N32-f pre-context ID is created and sent towards the peer \gls{sepp} the N32-c channel, together with the configured cipher suites.
The following line shows that a similar information is expected from the other party as well, this time containing cipher suite agreed by both endpoints.
The process validates whether the target address maches its own \gls{sepp} address, only proceeding to create a final N32-f context ID from the two precontext IDs if this condition is met.
This check is necessary for every incoming message in order to ensure correct execution of the protocol flow.
Section \ref{sec:issues} explains this requirement in detail and what impact it has on the verification result.

Subsequently, the \glspl{sepp} exchange encryption policy and modification policy.
The information is accompanied by the target \gls{sepp} address and the N32-f context ID agreed during the previous step.
Again, the process only continues if the incoming message contains the correct target address, N32-f context ID and an encryption policy that matches its own.
Recall that the \gls{3gpp} specification assumes these protection policies to be agreed by the \gls{sepp} operators in advance (see section \ref{sec:n32}).
Following a successful protecion policy exchange, the \gls{ipx} security information lists are shared, i.e. an identifier of each \gls{sepp}'s directly connected \gls{ipx} provider and its public key.

Subsequently, the master key is derived using the above-mentioned constructor {\sffamily deriveMasterKey} and the session's message counter, initialized with the value 0.
The message counter is chosen as an input parameter for this private function, since it guarantees a different output and thus, the creation of a new key when the key is refreshed after each N32-f message exchange.
If no input would be provided whatsoever, the function would produce the same value every time.
Based on this master key, further session keys and initialization vectors are derived which are used in the N32-f \gls{aead} operations.
Since the protocol distinguishes session keys and initialization vectors to be used based on the \gls{sepp}'s role in the N32-c communication, the functions {\sffamily deriveSessionKey} and {\sffamily deriveIV} consume a flag indicating whether the \gls{sepp} initiated the N32-c session ({\sffamily SEND}) or not ({\sffamily RECV}), in addition to the master key.
Lastly, the agreed session parameters are stored in the \gls{sepp}'s local storage table.

\begin{lstlisting}[caption={Definition of the sending N32-c handshake process},label={lst:n32c-handshake-send},firstnumber=307]
let N32cSendHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    (* msg 1: Sec_Param_Ex_Req *)
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    (* msg 2: Sec_Param_Ex_Resp *)
    in(n32c, (
        =sepp_a_addr, ciphers_b: bitstring, n32f_pid_b: bitstring
    ));
    let n32f_cid = deriveContextId(n32f_pid, n32f_pid_b) in
    event sendN32fContext(sepp_a_addr, n32f_pid, n32f_pid_b, n32f_cid);

    (* verify matching encryption policies *)
    (* msg 3: Sec_Param_Ex_Req *)
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));
    (* msg 4: Sec_Param_Ex_Resp *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, =encp_a, modp_b: bitstring
    ));

    (* exchange ipx information *)
    (* msg 5: Sec_Param_Ex_Req *)
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));
    (* msg 6: Sec_Param_Ex_Resp *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, ipx_b_id: bitstring, ipx_b_key: pubkey
    ));
    (* bidirectional n32c channel remains open *)

    (* key derivation *)
    let msg_cnt_a = 0 in
    let master_key_a = deriveMasterKey(n32f_cid) in
    event sendMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_req_key_a = deriveSessionKey(SEND, REQ, master_key_a) in
    let rev_req_key_a = deriveSessionKey(RECV, REQ, master_key_a) in
    let par_res_key_a = deriveSessionKey(SEND, RES, master_key_a) in
    let rev_res_key_a = deriveSessionKey(RECV, RES, master_key_a) in
    let par_req_iv_a = deriveIV(SEND, REQ, master_key_a) in
    let rev_req_iv_a = deriveIV(RECV, REQ, master_key_a) in
    let par_res_iv_a = deriveIV(SEND, RES, master_key_a) in
    let rev_res_iv_a = deriveIV(RECV, RES, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

The receiving N32-c handshake process is structured similarly, with a few key distinctions (see listing~\ref{lst:n32c-handshake-recv}).
Firstly, the \gls{sepp} creates a fresh N32-f precontext ID.
Secondly, \gls{sepp} address, cipher suites, and N32-f precontext ID are received from the \gls{sepp} initiating the communication.
If the address of the receiving \gls{sepp} and the cipher suites match, the \gls{sepp} responds with its own N32-f precontext ID and the agreed cipher suite.
The final N32-f context ID is derived in the same way as by the sending \gls{sepp}.

Subsequently, the protecion policies are exchanged.
As is the case in the sending process, the receiving party of the N32-c handshake only progresses if the N32-f context ID and the configured encryption policies in both \glspl{sepp} are the same.
This step is again followed by the exchange of information related to the involved \gls{ipx} providers.

The parameter exchanges are followed by the derivation of master key, session keys and initialization vectors.
The only difference to the sending N32-c handshake process is the flags used for creation of the session keys.
In the listing below, the parallel session key and \gls{iv} are derived with the constant parameter {\sffamily RECV}, since the \gls{sepp} is on the receiving end of the initial N32-c handshake.
In contrast, the function {\sffamily deriveSessionKey} uses parameter {\sffamily SEND} for the reverse session key in initialization vector.
Lastly, all session parameters are stored in the \gls{sepp}'s local storage.

\begin{lstlisting}[caption={Definition of the receiving N32-c handshake process},label={lst:n32c-handshake-recv},firstnumber=356]
let N32cRecvHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    (* msg 1: Sec_Param_Ex_Req *)
    in(n32c, (
        =sepp_a_addr, =ciphers_a, n32f_pid_b: bitstring
    ));
    (* msg 2: Sec_Param_Ex_Resp *)
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    let n32f_cid = deriveContextId(n32f_pid_b, n32f_pid) in
    event recvN32fContext(sepp_a_addr, n32f_pid_b, n32f_pid, n32f_cid);

    (* verify matching encryption policies *)
    (* msg 3: Sec_Param_Ex_Req *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, =encp_a, modp_b: bitstring
    ));
    (* msg 4: Sec_Param_Ex_Resp *)
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));

    (* exchange ipx information *)
    (* msg 5: Sec_Param_Ex_Req *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, ipx_b_id: bitstring, ipx_b_key: pubkey
    ));
    (* msg 6: Sec_Param_Ex_Resp *)
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));
    (* bidirectional n32c channel remains open *)

    (* key derivation *)
    let msg_cnt_a = 0 in
    let master_key_a = deriveMasterKey(n32f_cid) in
    event recvMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_req_key_a = deriveSessionKey(RECV, REQ, master_key_a) in
    let rev_req_key_a = deriveSessionKey(SEND, REQ, master_key_a) in
    let par_res_key_a = deriveSessionKey(RECV, RES, master_key_a) in
    let rev_res_key_a = deriveSessionKey(SEND, RES, master_key_a) in
    let par_req_iv_a = deriveIV(RECV, REQ, master_key_a) in
    let rev_req_iv_a = deriveIV(SEND, REQ, master_key_a) in
    let par_res_iv_a = deriveIV(RECV, RES, master_key_a) in
    let rev_res_iv_a = deriveIV(SEND, RES, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

Listing~\ref{lst:n32c-error-send} shows the sending \gls{sepp}'s part of error signaling process carried out over N32-c, the details of which are described not in the security specification \gls{ts} 33.501, but \gls{ts} 33.573 (c.f. \cite{3gpp.29.573}, p. 18).

After detecting an error in an incoming N32-f message, modelled by receiving a message containing on the internal channel {\sffamily err\_a}, the \gls{sepp} retrieves the related N32-f context from its local storage.
Based on this information, the process initiates an error signaling message over the N32-c channel, containing the target \gls{sepp}'s address, the N32-f context ID, and the identifier of the flawed message received.

The \gls{sepp} then awaits a respone from its peer, confirming the receipt of the error message and informing the sending \gls{sepp} about the result of the error signaling.
How the contents of this response are determined is shown in the next listing~\ref{lst:n32c-error-recv}.

\begin{lstlisting}[caption={Definition of the sending error signaling process},label={lst:n32c-error-send},firstnumber=406]
let N32cSendErrorSeppA(sepp_a_addr: bitstring)=
    in(err_a, (n32f_context': bitstring, msg_id: nat));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send error notification *)
    out(n32c, (sepp_b_addr, n32f_context, msg_id));

    (* receive confirmation *)
    in(n32c, (
        =sepp_a_addr, =n32f_context, =msg_id, status_code: bitstring
    ));
    event sendErrorSeppA(n32f_context, msg_id, status_code).
\end{lstlisting}

Listing~\ref{lst:n32c-error-recv} contains the receiving part of the error signaling procedure.
After receiving an error signaling message from its peer on N32-c, the \gls{sepp} retrieves the locally stored session parameters, based on the N32-f context ID.

The \gls{sepp} performs a validation of the received message ID, checking whether it is lower than or equal to the locally maintained message counter.
This ensures a previous message with the same id has been sent.
A confirmation message including a status code is signaled back to the peer \gls{sepp} over N32-c.
If above-mentioned check was successful, this status code is the constant {\sffamily SUCC}, else {\sffamily FAIL}.

\begin{lstlisting}[caption={Definition of the receiving error signaling process},label={lst:n32c-error-recv},firstnumber=427]
let N32cRecvErrorSeppA(sepp_a_addr: bitstring)=
    in(n32c, (
        =sepp_a_addr, n32f_context': bitstring, msg_id: nat
    ));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send confirmation *)
    if msg_id <= msg_cnt_a then
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, SUCC));
        event recvErrorSeppA(n32f_context, msg_id, SUCC)
    )
    else
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, FAIL));
        event recvErrorSeppA(n32f_context, msg_id, FAIL)
    ).
\end{lstlisting}

\subsection{N32-f Processes}

Prior to any inter-operator signaling, an \gls{nf} has to initiate an \gls{http} request towards a recipient in a foreign network.
Listing \ref{lst:nf-request} shows the process of an \gls{nf} in \gls{plmn} A creating a fresh message, compiling it into an \gls{http} request including source address, destination address, and message type ({\sffamily REQ}) before sending it to its local \gls{sepp} over the {\sffamily plmn\_a} channel.
The actual information sent to the \gls{sepp} is a tuple of the message direction ({\sffamily SEND}) and the \gls{http} message itself.
While the former is not necessary in real-world implementations, it prevents messages being erroneously consumed from the \gls{nf} response process displayed in the next listing.

\begin{lstlisting}[caption={Definition of the requesting NF process},label={lst:nf-request},firstnumber=595]
let NfARequest(nf_a_addr: bitstring, nf_b_addr: bitstring)=
    new msg_body: bitstring;
    let http_message =
        createHttp(nf_a_addr, nf_b_addr, REQ, msg_body) in
    event sendHttpMsgNfA(REQ, msg_body);
    out(plmn_a, (SEND, http_message)).
\end{lstlisting}

The \gls{nf} response process shown in listing \ref{lst:nf-respond} expects an incoming \gls{http} message.
The equality sign before the constant {\sffamily RECV} is a shorthand for the validation of the message direction parameter.
In this case, only tuples consisting of the constant {\sffamily RECV} and a variable of type {\sffamily http} will be consumed by the process.

Subsequently, the \gls{http} message is deconstructed into its original components.
The action of the \gls{nf} varies depending on the contained message type.
If the message received is a request, a response is being sent that contains the same message body.
Otherwise, only an event is triggered indicating the receipt of an \gls{http} response.

\begin{lstlisting}[caption={Definition of the responding NF process},label={lst:nf-respond},firstnumber=595]
let NfAResponse(nf_a_addr: bitstring, nf_b_addr: bitstring)=
    in(plmn_a, (=RECV, msg: http));
    let createHttp(nf_b_addr: bitstring,
        =nf_a_addr,
        msg_type: bitstring,
        msg_body: bitstring) = msg in
    if msg_type = REQ then
    (
        event sendHttpMsgNfA(RES, msg_body);
        out(plmn_a, (SEND, createHttp(nf_a_addr, nf_b_addr, RES,msg_body)))
    )
    else event recvHttpMsgNfA(RES, msg_body).
\end{lstlisting}

Listing~\ref{lst:n32f-send} shows the sending N32-f process, i.e. the process in which signaling data is actually transferred.
For the purpose of formal verification, the exact contents of said signaling messages do are of no concern.
Hence, the sending \gls{sepp} initial creates a fresh messages of type {\sffamily http}.
In real-world deployments, this message would be received from a \gls{nf} in the \gls{sepp}'s own \gls{plmn}.
After retrieving the session context for the target \gls{sepp}, said \gls{http} message is split into a confidential and non-confidential part using the {\sffamily reformatHttp} deconstructor and the data-type encryption policy.

Next, the message is assigned a unique identifier by incrementing the locally maintained message counter.
All information used as \gls{aad} is combined into a single structure before being put into the \gls{aead} encryption function.
The encryption function uses the parallel session key, the parallel initialization vector, the confidential part of the signaling message, and the \gls{aad} to produce the encrypted message content ({\sffamily payload}) and a \gls{jwe} tag required for authentication.
These information are combined with further supplementary information as shown in figure \ref{fig:n32f-message} and then sent towards the peer \gls{sepp} over the public N32-f channel.

Lastly, the local N32-f context is updated to reflect the incremented message counter.

\begin{lstlisting}[caption={Definition of the sending N32-f signaling transmission process},label={lst:n32f-send},firstnumber=595]
let N32fSendSeppA()=
    in(plmn_a, (=SEND, http_message: http));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in

    (* rewrite http message *)
    let createHttp(source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        msg_body: bitstring) = http_message in
    event recvHttpMsgSeppA(msg_type, msg_body);
    let conf: bitstring = getConf(msg_body, encp_a) in
    let nonconf: bitstring = getNonconf(msg_body, encp_a) in

    let msg_id: nat = msg_cnt_a + 1 in
    let associated_data = combineAAD(
        source_addr, destination_addr, msg_type,
        nonconf, msg_id, ipx_a_id, n32f_context
    ) in

    (* determine session key & nonce *)
    let key = (if msg_type = REQ then
        par_req_key_a else
        par_res_key_a) in
    let nonce = (if msg_type = REQ then
        deriveNonce(par_req_iv_a, msg_id) else
        deriveNonce(par_res_iv_a, msg_id)) in

    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        key,
        nonce,
        conf,
        associated_data
    ) in
    event sendN32fMsgSeppA(n32f_context, msg_id, conf, nonconf);
    out(n32f_a, (sepp_b_addr, prins'(
        ciphers_a, nonce, associated_data, payload, jwe_tag
    )));
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

The receiving part of N32-f signaling is modelled by the process in listing~\ref{lst:n32f-recv}.
The \gls{sepp} initially receives a modified \gls{prins} message.
Note, that even if none of the intermediate \gls{ipx} providers is required to make changes to a N32-f message, they are still be expected to each create an empty \gls{json} patch and sign it - hence the data type {\sffamily modprins}.

Next, the received message is decomposed into parts written by the sending \gls{sepp} and the two added patches.
The \gls{aad} object is further broken down to access non-confidential parts of the original message as well as the N32-f message ID, the identity of the authorized \gls{ipx}, and the related N32-f context.
The latter is required to look-up the matching session context in local storage in lines 646-650.
The following \gls{aead} decryption operation, if successful, yields the encrypted part of the original N32-f signaling message.

Afterwards, the first \gls{json} patch is validated by checking the validity of the \gls{jws} object, whether its origin is the same as specified by the sending \gls{sepp} in parameter {\sffamily auth\_ipx\_id}, by ensuring the operations are part of the modification policy, and by validating the contained \gls{jwe} tag is the same as the one in the original message.
If all four checks pass successfully, the patch is considered valid, else invalid, and an appropriate flag is set.
The modification of the patch by the second \gls{ipx} provider is omitted in the listing below for brevity.
Validation happens in the exact same way with one minor deviation: Instead of validating the source of the \gls{json} patch against the authorized \gls{ipx} identifier specified by the sending \gls{sepp}, it is compared against the identifier of the second \gls{ipx} provider on the path, which is locally stored in the N32-f context.
Lastly, if both \gls{json} patch validations succeed, the message as a whole is considered valid.
Any subsequent actions, such as reformatting the N32-f message to an \gls{http} message while applying the two patches, are not considered in the model.

\lstset{escapeinside=~~}
\begin{lstlisting}[caption={Definition of the receiving N32-f signaling transmission process},label={lst:n32f-recv},firstnumber=623]
let N32fRecvSeppA(sepp_a_addr: bitstring)=
    in(n32f_a, (=sepp_a_addr, prins_messsage: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        nonce: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id: bitstring,
        n32f_context': bitstring
    ) = dataToIntegrityProtect in

    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* determine session key & nonce *)
    let key = (if msg_type = REQ then
        rev_req_key_a else
        rev_res_key_a) in
    let nonce = (if msg_type = REQ then
        deriveNonce(rev_req_iv_a, msg_id) else
        deriveNonce(rev_res_iv_a, msg_id)) in

    let conf = aeadDecrypt(
        key,
        nonce,
        (dataToIntegrityProtectAndCipher, jwe_tag),
        dataToIntegrityProtect
    ) in
    event recvN32fMsgSeppA(n32f_context', msg_id, conf, nonconf);

    (* verify ipx b json patch *)
    let jsonPatch(
        =modp_b,
        =auth_ipx_id,
        =jwe_tag,
        ipx_b_jws: bitstring
    ) = ipx_b_mods in
    if not(validPrinsSign(ipx_b_jws, ipx_b_key)) then
    (
        event recvInvalIpxPatchSeppA(
            auth_ipx_id, n32f_context, msg_id, jwe_tag, ipx_b_mods
        );
        out(err_a, (n32f_context, msg_id))
    )
    else
        event recvValidIpxPatchSeppA(
            auth_ipx_id, n32f_context, msg_id, jwe_tag, ipx_b_mods
        );
    ~\Suppressnumber~

    (* validation of second patch omitted *)
    ~\Reactivatenumber{703}~

    (* all patches valid *)
    if validPrinsModSign(ipx_a_jws, ipx_a_key) &&
        validPrinsSign(ipx_b_jws, ipx_b_key) &&
        policyValidation(nonconf, encp_a) then
    let msg_body = applyPatches((conf, nonconf), modp_b, modp_a) in
    let http_message = createHttp(
        source_addr,
        destination_addr,
        msg_type,
        msg_body) in
    event sendHttpMsgSeppA(msg_type, msg_body);
    out(plmn_a, (RECV, http_message)).
\end{lstlisting}

\subsection{IPX Processes}

As with the \glspl{sepp}, the two directly connected intermediaries providers are modelled separately as \gls{ipx} A and \gls{ipx} B.
Listing~\ref{lst:ipx-send} shows the process of \gls{ipx} A receiving a message from its peer \gls{sepp}, applying the first \gls{json} patch and then sending it on to the next \gls{ipx} provider.

After receiving the N32-f message, it is decomposed into its individual parts.
This operation, among other information, yields the \gls{jwe} tag required for writing legitimate message modifications.
Lines 838-840 show how the message operations (i.e. the modifications itself), the \gls{ipx} provider ID, the \gls{jwe} tag, and a \gls{jws} signature of the complete message are combined to form this patch.

The following decomposition of the \gls{aad} object solely serves the purpose of accessing the N32-f context ID and the message ID used by event {\sffamily ipxSendA} at the end of the process.
Section \ref{sec:analysis} describes how this information is used for verification.
Afterwards, the \gls{ipx} provider's patch is combined with the original message contents in lines 851-859 to form a modified \gls{prins} message of type {\sffamily modprins}.
Note, that there is an additional, empty \gls{json} patch written by this first \gls{ipx} provider.
This is done to simplify the model by not creating a separate data-type for a modified \gls{prins} message with a single \gls{json} patch.
Finally, the modified message is sent towards the next \gls{ipx} provider.

\begin{lstlisting}[caption={Definition of the sending IPX process},label={lst:ipx-send},firstnumber=825]
let N32fSendIpxA(id: bitstring, privkey_ipx_a: privkey, ops: bitstring)=
    in(n32f_a, (sepp_b_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey_ipx_a)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        =id,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    event ipxSendA(n32f_context, msg_id, jwe_tag, modifications);
    out(n32f_i, (sepp_b_addr, modified_message)).
\end{lstlisting}

Listing~\ref{lst:ipx-recv} shows the process of \gls{ipx} A receiving a N32-f message from the \gls{ipx} network that is to be forwarded to its directly connected \gls{sepp}.
The actions performed are largely the same as in the sending process above, the difference being that this time, an already modified \gls{prins} message is received on the interface between \gls{ipx} providers.
Further, the empty \gls{json} patch inserted by the previous \gls{ipx} provider is replaced before forwarding the updated message to the receiving \gls{sepp}.

\begin{lstlisting}[caption={Definition of the receiving IPX process},label={lst:ipx-recv},firstnumber=863]
let N32fRecvIpxA(id: bitstring, privkey_ipx_a: privkey, ops: bitstring)=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        =EMPTY
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey_ipx_a)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    event ipxRecvA(n32f_context, msg_id, jwe_tag, modifications);
    out(n32f_a, (sepp_a_addr, modified_message)).
\end{lstlisting}

\subsection{Main process}

Listing~\ref{lst:main-proc} shows how the main process of the \textsc{ProVerif} model is defined.
This is where the previously described processes are combined in a way that models the overall protocol flow.
For brevity, the definition of variables, such as idientifiers for \gls{sepp} and \gls{ipx} nodes, cryptographic keys, and protection policies, have been omitted.

The execution is structured into six separate phases using the keyword {\sffamily sync}.
As noted in section~\ref{sec:formal}, \textsc{ProVerif} synchronization points ensure that processes are executed in a particular order -- according to the integer specified behind the {\sffamily sync} keyword.
Beyond that, all individual processes are combined using the pipe operator ,,~{\sffamily |}~'', denoting parallel execution.
Hence, processes in one synchronization group are run together and have to terminate successfully before the process continues with the next synchronization group.
Processes are not forcefully terminated preemptively.

Processes that are not specifically marked with {\sffamily sync} run in the default synchronization group~0.
In the created \gls{prins} model this group comprises all N32-c processes necessary to establish a connection between the two \glspl{sepp}.
Information passed to these processes include \gls{plmn} IDs, \gls{sepp} addresses as well as the session parameters ciphersuites, protection policies and \gls{ipx} provider information.
All of these information are expected to be preconfigured and remain unchanged in communication with one peer \gls{sepp} over one particular \gls{ipx} provider.
In contrast to the rest of the model, the subprocesses comprising the initial N32-c handshake is executed only once by each communicating party.
This is to ensure each possible role of a \gls{sepp} --i.e. initiating and responding to a N32-c session establishment-- is covered, while simultaneously reducing complexity for the rest of the verification by ensuring there is at most two active sessions stored in each of the \glspl{sepp}.

Synchronization group~1 (lines TODO) contains the set of processes relevant for creating a new \gls{http} Request in each of the \glspl{plmn} any sending it via N32-f.
That is, processes of sending \glspl{nf} and sending \glspl{sepp} on both sides of the inter-operator communication.
The \gls{nf} processes {\sffamily NfARequest} and {\sffamily NfBRequest} each consume the source and destination address of the message to be created.
While in real world deloyments, operators would likely choose to not reveal the \gls{ip} addresses of their Network Functions and instead provide their partner networks with \glspl{fqdn}, this does not make a difference for the purposes of the \gls{prins} verification.
The \gls{sepp} processes {\sffamily N32fSendSeppA} and {\sffamily N32fSendSeppB} do not consume any parameters, instead retrieving all necessary information from the previously established N32-f process.
Starting from this synchronization group, each process is denoted with a preceeding exclamation mark operator ,,~{\sffamily !}~''.
This instructs \textsc{ProVerif} to spawn multiple instances of a given process.
By doing so, it is ensured more than one \gls{prins} message can be transferred between the two networks.
Furthermore, the tool is able to check for potential security flaws due to confusion of N32 sessions by any of the legitimate participants.

Synchronization group~2 (lines TODO) comprises all \gls{ipx} processes to transport the previously created N32-f messages.
This includes sending and receiving processes by both well-behaving \gls{ipx} providers A and B as well as \gls{ipx} providers R1 and R2 intentionally violating the protocol.
Chapter \ref{chap:verification} further explains how these processes are used to explicitly check some security properties of \gls{prins}.
Each of these processes consumes an \gls{ipx} provider ID and a private key, required to create and sign \gls{json} patches for message modifications as well as the modifications itself.
The model assumes that information about the modifications to be performed has been exchanged between the \gls{ipx} provider and its directly connected \gls{sepp} out of band before session establishment and thus, is provided directly to the \gls{ipx} processes.

Synchronization group~3 (lines TODO) captures the receiving processes of \glspl{sepp} and \glspl{nf}, sending processes of both \glspl{sepp} in order to transmit responses to the incoming requests, as well as N32-c error handling processes.
The receiving \gls{sepp} processes {\sffamily N32fRecvSeppA} and {\sffamily N32fRecvSeppB} consume their own address in order to identify incoming N32-f messages directed at them from other messages sent by the same \gls{sepp}.
The same applies to the error handling processes {\sffamily N32cSendErrorSeppA} and {\sffamily N32cSendErrorSeppB} as well as {\sffamily N32cRecvErrorSeppA} and {\sffamily N32cRecvErrorSeppB}.
The \gls{nf} processes {\sffamily NfAResponse} and {\sffamily NfBResponse}, just as the request processes, consume source and destination addresses of the message to be created in response.

Synchronization group~4 and 5 mirror groups 2 and 3 in that the response messages created during the previous phase are transmitted via the \gls{ipx} providers and received by the peer elements.
The only exception in synchronization group~5 is that no response is being sent following the receipt of a response message. Hence, sending \gls{sepp} processes are omitted.

\begin{lstlisting}[caption={Definition of the main process},label={lst:main-proc},firstnumber=1183]
    (* process execution *)
    (
        (N32cSendHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
        (N32cRecvHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (N32cSendHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (N32cRecvHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |

        (sync 1; !NfARequest(nf_a_addr, nf_b_addr)) |
        (sync 1; !NfBRequest(nf_b_addr, nf_a_addr)) |
        (sync 1; !N32fSendSeppA()) |
        (sync 1; !N32fSendSeppB()) |

        (sync 2; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 2; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 2; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 2; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 2; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 2; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
        (sync 2; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 2; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |

        (sync 3; !N32fRecvSeppA(sepp_a_addr)) |
        (sync 3; !N32fRecvSeppB(sepp_b_addr)) |
        (sync 3; !NfAResponse(nf_a_addr, nf_b_addr)) |
        (sync 3; !NfBResponse(nf_b_addr, nf_a_addr)) |
        (sync 3; !N32cSendErrorSeppA(sepp_a_addr)) |
        (sync 3; !N32cRecvErrorSeppA(sepp_a_addr)) |
        (sync 3; !N32cSendErrorSeppB(sepp_b_addr)) |
        (sync 3; !N32cRecvErrorSeppB(sepp_b_addr)) |
        (sync 3; !N32fSendSeppA()) |
        (sync 3; !N32fSendSeppB()) |

        (sync 4; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 4; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 4; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 4; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 4; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 4; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
        (sync 4; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 4; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |

        (sync 5; !N32fRecvSeppA(sepp_a_addr)) |
        (sync 5; !N32fRecvSeppB(sepp_b_addr)) |
        (sync 5; !NfAResponse(nf_a_addr, nf_b_addr)) |
        (sync 5; !NfBResponse(nf_b_addr, nf_a_addr)) |
        (sync 5; !N32cSendErrorSeppA(sepp_a_addr)) |
        (sync 5; !N32cRecvErrorSeppA(sepp_a_addr)) |
        (sync 5; !N32cSendErrorSeppB(sepp_b_addr)) |
        (sync 5; !N32cRecvErrorSeppB(sepp_b_addr))
    )
\end{lstlisting}