\lstdefinestyle{proverif}{
    basicstyle=\footnotesize\sffamily,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keywordstyle=\color{ForestGreen}\textbf,
    commentstyle=\color{Gray}\textit,
    escapechar=\%,
    frame=tb,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    morekeywords={let, in, if, then, else, event, inj, new, out, fun, reduc, forall, otherwise, insert, get, table, type, free, const, process, sync},
    comment=[l]{(*}
}
\lstset{style=proverif}

\subsection{Supporting Constructs}

As noted in the previous section, \textsc{ProVerif} features a basic type system.
Aside from allowing for a closer representation of the actual protocol implementation, types also serve as guardrails while modeling the honest participants in that, for example, a constructor expecting an input of type bitstring cannot be called with a different type.
However, it should be noted that types are ignored by the adversary during verification stage unless explicitly defined otherwise, allowing \textsc{ProVerif} to detect potential type flaw attacks (c.f. \cite{blanchet2020proverif}, p.~38).

In addition to \textsc{ProVerif}'s built-in data types, a number of custom types displayed in listing~\ref{lst:types} are defined.
Compound data structures, such as {\sffamily aad}, {\sffamily prins}, {\sffamily modprins}, and {\sffamily ipxmod}, are defined solely for convenience and improved readability so as to not pass each of their respective subcomponents individually.
Other types are supposed to resemble data with specific characteristics.
A \gls{mac}, for example, is modeled by the type {\sffamily mac} that cannot be transformed back into its original components.
Data of type {\sffamily pubkey} on the other hand, can only be derived from a related {\sffamily privkey}.

\begin{lstlisting}[caption={Custom type definitions},label={lst:types},firstnumber=10]
type key.                           (* symmetric key *)
type mac.                           (* message authentication code *)
type http.                          (* http message *)
type privkey.                       (* asymmetric privat key *)
type pubkey.                        (* asymmetric public key *)
type prins.                         (* prins message *)
type modprins.                      (* modified prins message w/ patches *)
type aad.                           (* additional authenticated data *)
type ipxmod.                        (* ipx json patch *)
\end{lstlisting}

Listing~\ref{lst:channels} shows the defined channels used to transport messages between processes.
By default, channels follow the Dolev-Yao model, meaning that all transferred information can be read, modified, intercepted or arbitrarily created by the adversary.
Secure channels that the attacker has no access to can be modeled by explicitly annotating them as private.

Three public channels are defined in order to represent the logical N32-f message flow from the sending \gls{sepp} to the first \gls{ipx} provider ({\sffamily nf32\_a}), from there to the next \gls{ipx} node ({\sffamily nf32\_i}), and finally to the receiving \gls{sepp} ({\sffamily nf32\_b}) or vice versa.
If all N32-f communication would be modeled using a single channel, the verification tool would have no information about the intended message flow involing the intermediary nodes.
In such a case, a message sent by one \gls{sepp} could be received directly by another \gls{sepp} without traversing any of the \gls{ipx} providers.
Beyond that, separate channels also alleviate the need to encode full-featured routing information in every single message, detailed further in section~\ref{sec:issues}.

In contrast to N32-f, N32-c communication utilizes a single private channel.
Logically, this represents an end-to-end channel between two communicating \glspl{sepp} guaranteeing both confidentiality and integrity of messages.
As highlighted in section~\ref{sec:goal}, proving security of established, well-tested protocols is considered out of scope.
Since the protection of N32-c traffic completely relies on \gls{tls}, the protocol is assumed to perfectly secure in that regard.

The remaining channels transport messages within the \glspl{sepp} themselves or their respective \glspl{plmn} and thus, are also considered secure.
{\sffamily err\_a} and {\sffamily err\_b} are used internally to the two peers, \gls{sepp}~A and \gls{sepp}~B, to pass information about errors in N32-f messages from the receiving N32-f processes to the those handling error signaling via N32-c.
{\sffamily plmn\_a} and {\sffamily plmn\_b} connect the \gls{nf} in each of the networks to its local \gls{sepp}.

\begin{lstlisting}[caption={Custom channel declarations},label={lst:channels},firstnumber=22]
free n32f_a: channel.               (* Channel between SEPP A and IPX A *)
free n32f_i: channel.               (* Channel between IPX Providers *)
free n32f_b: channel.               (* Channel between IPX B and SEPP B *)
free n32c_a: channel [private].     (* Channel between SEPP A and SEPP B *)
free n32c_b: channel [private].     (* Channel between SEPP A and SEPP B *)
free plmn_a: channel [private].     (* PLMN A internal channel *)
free plmn_b: channel [private].     (* PLMN B internal channel *)
free err_a: channel [private].      (* Internal error signaling Sepp A *)
free err_b: channel [private].      (* Internal error signaling Sepp B *)
\end{lstlisting}

Listing~\ref{lst:constants} provides an overview of global constants used by the protocol model.
These are utilized at different points of the process execution to represent fixed, known values or flags.
An empty \gls{json} patch written by \gls{ipx} providers is modeled by the {\sffamily EMPTY} constant (see listing~\ref{lst:ipx-send}).
{\sffamily SEND} and {\sffamily RECV} flags are utilized, for example, during derivation of the N32-f keys to indicate whether or not the \gls{sepp} initiated the N32-c handshake (see listing~\ref{lst:n32c-handshake-send} and \ref{lst:n32c-handshake-recv}).
{\sffamily SUCC} and {\sffamily FAIL} are constants representing the status code for success or failure in error signaling procedures (see listing~\ref{lst:n32c-error-send} and \ref{lst:n32c-error-recv})
Lastly, {\sffamily REQ} and {\sffamily RES} indicate the type of \gls{http} message being exchanged between the two \glspl{nf} communicating via the inter-operator interface.

\begin{lstlisting}[caption={Global constant declarations},label={lst:constants},firstnumber=34]
const EMPTY: ipxmod.                (* the empty ipx patch *)
const SEND: bitstring.              (* sending flag *)
const RECV: bitstring.              (* receiving flag *)
const SUCC: bitstring.              (* success flag *)
const FAIL: bitstring.              (* failure flag *)
const REQ: bitstring.               (* HTTP Request *)
const RES: bitstring.               (* HTTP Response *)
\end{lstlisting}

\textsc{ProVerif}'s tables are used to model each \gls{sepp}'s local storage for N32-f context information.
Each \gls{sepp} has to keep track of several attributes, listed in section~\ref{sec:n32}, in order to correlate N32-f messages to a previously established session and check the validity of incoming messages.
The created model does not consider all of these information, abstracting away the following attributes cited in the \gls{3gpp} specification:
(1)~The remote \gls{sepp} ID, part of the N32-f peer information, is not considered.
In real-world implementations, this attribute helps peers to distinguish multiple \gls{sepp} instances in a foreign \gls{plmn}.
The model assumes there is only a single instance in each network.
(2)~The N32-f context information, which contains information about the validity (i.e. lifetime) of session keys and whether or not \gls{tls} shall be used to transport N32-f messages.
Firstly, the session key lifetime cannot be verified using formal methods, due to the lack of appropriate temporal constructs.
Secondly, it is assumed \gls{prins} is exclusively used to carry N32-f messages.

\begin{lstlisting}[caption={Declaration of local SEPP storage using tables},label={lst:tables},firstnumber=44]
table storeSeppA(
    bitstring,                      (* SEPP B PLMN ID *)
    bitstring,                      (* SEPP B Address *)
    bitstring,                      (* N32-f Context ID *)
    nat,                            (* N32-f Message Counter *)
    key,                            (* parallel request key *)
    key,                            (* parallel response key *)
    key,                            (* reverse request key *)
    key,                            (* reverse response key *)
    bitstring,                      (* parallel request IV *)
    bitstring,                      (* parallel response IV *)
    bitstring,                      (* reverse request IV *)
    bitstring,                      (* reverse response IV *)
    bitstring,                      (* JWE Ciphersuite *)
    bitstring,                      (* Data-type encryption policy *)
    bitstring,                      (* SEPP A modification policy *)
    bitstring,                      (* SEPP B modification policy *)
    bitstring,                      (* IPX A id *)
    pubkey,                         (* IPX A public key *)
    bitstring,                      (* IPX B id *)
    pubkey).                        (* IPX B public key *)
\end{lstlisting}

Data constructors are used to model type transformations in \textsc{ProVerif}.
Listing~\ref{lst:constructor} shows an example that combines the information elements added by intermediate \gls{ipx} providers when applying message modifications.
This particular constructor takes four information elements of type {\sffamily bitstring}, {\sffamily mac}, {\sffamily bitstring}, and {\sffamily bitstring} and produces a single {\sffamily ipxmod} element.
Fundamentally, this follows the same syntax as ordinary \textsc{ProVerif} constructors.
However, the {\sffamily [data]} annotation has the effect that the adversary is able to deconstruct the resulting data type into its original subcomponents at any time (c.f. \cite{blanchet2020proverif}, p.~37), even without a related deconstructor explicitly defined.

\begin{lstlisting}[caption={Definition of custom data constructor},label={lst:constructor},firstnumber=103]
fun jsonPatch(bitstring,            (* Operations *)
    bitstring,                      (* IPX Id *)
    mac,                            (* JWE Tag *)
    bitstring): ipxmod [data].      (* JWS Signature *)
\end{lstlisting}

Listing~\ref{lst:functions} shows an example of custom functions being used in the \gls{prins} model.
By default, they are available to all protocol participants, including the adversary.
Below functions for the derivation of N32-f context ID, master key, session key, \gls{aes} initialization vector and nonce as well as the application of json patches to an incoming N32-f message are one-way functions.
Since none of them defines a related deconstructor, the original function inputs cannot be derived from its output.

The function {\sffamily deriveMasterKey} is uniquely defined as a private function due to a limitation of the created model.
According to the \gls{3gpp} specification, the N32-f master key is derived from the N32-c session using \gls{tls} keying material exporters (\cite{3gpp.33.501}, p.~132).
Since the \gls{tls} protocol is not modeled in detail, the {\sffamily deriveMasterKey} function is defined as a substitue not available to the Dolev-Yao adversary.
Section \ref{sec:issues} further describes the benefits and drawbacks of modeling the key derivation in this way.

\begin{lstlisting}[caption={Definition of custom one-way functions},label={lst:functions},firstnumber=124]
fun deriveContextId(bitstring, bitstring): bitstring.
fun deriveSessionKey(bitstring, bitstring, key): key.
fun deriveIV(bitstring, bitstring, key): bitstring.
fun deriveNonce(bitstring, nat): bitstring.
fun applyPatches(bitstring, bitstring, bitstring): bitstring.
fun deriveMasterKey(bitstring): key [private].
\end{lstlisting}

In contrast to the functions displayed above, there are other constructors defined with one or more related deconstructors, reverting a particular operation.
This is examplified by the {\sffamily sign} function in listing~\ref{lst:destructors}.
Given two inputs of type {\sffamily bitstring} and {\sffamily privkey}, the function creates a new {\sffamily bitstring}, resembling a digital signature.
The related deconstructor {\sffamily checkSign} takes two arguments of type {\sffamily bitstring} and {\sffamily pubkey} and returns the original message.
This operation only succeeds with the public key belonging to the private key that was previously used for signing the message, i.e. if the signature is valid.
The second deconstructor depicted in the listing below is provided to allow the adversary to retrieve signed message contents without possessing the public key for validation, as suggested by the official \textsc{ProVerif} user's manual (c.f. \cite{blanchet2020proverif}, p.~14).

\begin{lstlisting}[caption={Definition of custom constructors and destructors},label={lst:destructors},firstnumber=141]
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey;
    checkSign(sign(m, k), pk(k)) = m.
reduc forall m: bitstring, k: privkey;
    getMess(sign(m, k)) = m.
\end{lstlisting}

\subsection{N32-c Processes}

According to the specification, N32-c communication comprises three different procedures: Key agreement, parameter exchange (e.g. protection policies or \gls{ipx} provider information), and error handling (c.f. \cite{3gpp.33.501}, p.~128).
The model created as part of this work combines the first two into a single procedure for initial session establishment and considers a separate error signaling procedure.
Each of them is defined by a sending and a receiving process.
Further, each process is modeled separately for \gls{sepp}~A and \gls{sepp}~B, since all processes access local storage, represented by a distinct table for each \gls{sepp} (see listing~\ref{lst:tables}).

Listing~\ref{lst:n32c-handshake-send} shows the sending process of the N32-c handshake for \gls{sepp}~A.
Initially, a fresh N32-f pre-context ID is created and sent towards the peer \gls{sepp} the N32-c channel, together with the configured cipher suites.
The receipt of the second message in lines 457-459 shows that the same information is expected from the other party as well, containing the cipher suite agreed by both endpoints.
This input operation validates whether the destination address maches the local \gls{sepp} address and only proceeds to the creation of a final N32-f context ID from the two precontext IDs if this condition is met.
This address check for incoming messages is necessary to ensure correct execution of the protocol flow.
Section \ref{sec:issues} explains this requirement in detail and what impact it has on the verification result.

Subsequently, the \glspl{sepp} exchange encryption policies and modification policies.
The information sent out as part of message 3 is accompanied by the destination \gls{sepp} address and the N32-f context ID agreed during the previous step.
The process only continues past the receipt of message 4 if the incoming message contains the correct destination address, N32-f context ID, and an encryption policy that matches its own.
Recall that the \gls{3gpp} specification assumes these protection policies to be agreed by the \gls{sepp} operators in advance (see section~\ref{sec:n32}).
Following a successful protecion policy exchange, messages 5 and 6 are used to share the \gls{ipx} security information lists, i.e. an identifier of each \gls{sepp}'s directly connected \gls{ipx} provider and its public key.

Subsequently, the master key is derived using the above-mentioned constructor {\sffamily deriveMasterKey}.
Based on this master key, the complete hierarchy of session keys and initialization vectors is derived as outlined in section~\ref{sec:n32}.
Since the protocol distinguishes session keys and initialization vectors to be used based on the \gls{sepp}'s role in the N32-c communication as well as the type of \gls{http} message transported, the functions {\sffamily deriveSessionKey} and {\sffamily deriveIV} consume a flag indicating whether the \gls{sepp} initiated the N32-c session ({\sffamily SEND}) or not ({\sffamily RECV}) and a flag indicating its use for \gls{http} requests or responses, in addition to the master key itself.
Lastly, the agreed session parameters are stored in the \gls{sepp}'s local storage table.

\begin{lstlisting}[caption={Definition of the sending N32-c handshake process},label={lst:n32c-handshake-send},firstnumber=447]
let N32cSendHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    (* msg 1: Sec_Param_Ex_Req *)
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    (* msg 2: Sec_Param_Ex_Resp *)
    in(n32c, (
        =sepp_a_addr, ciphers_b: bitstring, n32f_pid_b: bitstring
    ));
    let n32f_cid = deriveContextId(n32f_pid, n32f_pid_b) in
    event sendN32fContext(sepp_a_addr, n32f_pid, n32f_pid_b, n32f_cid);

    (* verify matching encryption policies *)
    (* msg 3: Sec_Param_Ex_Req *)
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));
    (* msg 4: Sec_Param_Ex_Resp *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, =encp_a, modp_b: bitstring
    ));

    (* exchange ipx information *)
    (* msg 5: Sec_Param_Ex_Req *)
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));
    (* msg 6: Sec_Param_Ex_Resp *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, ipx_b_id: bitstring, ipx_b_key: pubkey
    ));
    (* bidirectional n32c channel remains open *)

    (* key derivation *)
    let msg_cnt_a = 0 in
    let master_key_a = deriveMasterKey(n32f_cid) in
    event sendMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_req_key_a = deriveSessionKey(SEND, REQ, master_key_a) in
    let rev_req_key_a = deriveSessionKey(RECV, REQ, master_key_a) in
    let par_res_key_a = deriveSessionKey(SEND, RES, master_key_a) in
    let rev_res_key_a = deriveSessionKey(RECV, RES, master_key_a) in
    let par_req_iv_a = deriveIV(SEND, REQ, master_key_a) in
    let rev_req_iv_a = deriveIV(RECV, REQ, master_key_a) in
    let par_res_iv_a = deriveIV(SEND, RES, master_key_a) in
    let rev_res_iv_a = deriveIV(RECV, RES, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

The receiving N32-c handshake process is structured similarly to the sending one, with a few key distinctions (see listing~\ref{lst:n32c-handshake-recv}).
Firstly, the \gls{sepp} creates a fresh N32-f precontext ID.
Secondly, message one containing the destination \gls{sepp} address, a list of cipher suites, and a N32-f precontext ID are received from the \gls{sepp} initiating the communication.
If the address and cipher suites match the receiving \gls{sepp}'s locally configured parameters, it responds with its own N32-f precontext ID and the agreed cipher suite in message 2.
The final N32-f context ID is derived in the same way as by the sending \gls{sepp}.

Subsequently, the protecion policies are exchanged in messages 3 and 4.
As is the case in the sending process, the receiving party of the N32-c handshake only proceeds if the N32-f context ID and the configured encryption policies in both \glspl{sepp} are the same.
This step is again followed by the exchange of information related to the involved \gls{ipx} providers.

The parameter exchanges are followed by the derivation of master key, session keys and initialization vectors.
The only difference to the sending N32-c handshake process is the flags used for creation of the session keys.
In the listing below, the parallel session key and \gls{iv} are derived with the constant parameter {\sffamily RECV}, since the \gls{sepp} is on the receiving end of the initial N32-c handshake.
In contrast, the function {\sffamily deriveSessionKey} uses parameter {\sffamily SEND} for the reverse session key in initialization vector.
Lastly, all session parameters are stored in the \gls{sepp}'s local storage.

\begin{lstlisting}[caption={Definition of the receiving N32-c handshake process},label={lst:n32c-handshake-recv},firstnumber=501]
let N32cRecvHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    (* msg 1: Sec_Param_Ex_Req *)
    in(n32c, (
        =sepp_a_addr, =ciphers_a, n32f_pid_b: bitstring
    ));
    (* msg 2: Sec_Param_Ex_Resp *)
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    let n32f_cid = deriveContextId(n32f_pid_b, n32f_pid) in
    event recvN32fContext(sepp_a_addr, n32f_pid_b, n32f_pid, n32f_cid);

    (* verify matching encryption policies *)
    (* msg 3: Sec_Param_Ex_Req *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, =encp_a, modp_b: bitstring
    ));
    (* msg 4: Sec_Param_Ex_Resp *)
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));

    (* exchange ipx information *)
    (* msg 5: Sec_Param_Ex_Req *)
    in(n32c, (
        =sepp_a_addr, =n32f_cid, ipx_b_id: bitstring, ipx_b_key: pubkey
    ));
    (* msg 6: Sec_Param_Ex_Resp *)
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));
    (* bidirectional n32c channel remains open *)

    (* key derivation *)
    let msg_cnt_a = 0 in
    let master_key_a = deriveMasterKey(n32f_cid) in
    event recvMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_req_key_a = deriveSessionKey(RECV, REQ, master_key_a) in
    let rev_req_key_a = deriveSessionKey(SEND, REQ, master_key_a) in
    let par_res_key_a = deriveSessionKey(RECV, RES, master_key_a) in
    let rev_res_key_a = deriveSessionKey(SEND, RES, master_key_a) in
    let par_req_iv_a = deriveIV(RECV, REQ, master_key_a) in
    let rev_req_iv_a = deriveIV(SEND, REQ, master_key_a) in
    let par_res_iv_a = deriveIV(RECV, RES, master_key_a) in
    let rev_res_iv_a = deriveIV(SEND, RES, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

Listing~\ref{lst:n32c-error-send} shows the sending \gls{sepp}'s part of error signaling process carried out over N32-c, the details of which are described not in the security specification \gls{ts} 33.501, but \gls{ts} 33.573 (c.f. \cite{3gpp.29.573}, p.~18).

After detecting an error in an incoming N32-f message, modeled by receiving a message containing on the internal channel {\sffamily err\_a}, the \gls{sepp} retrieves the related N32-f context from its local storage.
Based on this information, the process initiates an error message over N32-c, containing the destination \gls{sepp}'s address, the N32-f context ID, and the ID of the flawed message received.

The \gls{sepp} then awaits a response from its peer, confirming the receipt of said error message.
The related input operation validates the correct \gls{sepp} address, matching N32-f context ID and message ID in order to ensure different error messages are not mixed up.
How the contents of this response are determined by the \gls{sepp} responding to such error signaling is shown in the next listing~\ref{lst:n32c-error-recv}.

\begin{lstlisting}[caption={Definition of the sending error signaling process},label={lst:n32c-error-send},firstnumber=555]
let N32cSendErrorSeppA(sepp_a_addr: bitstring)=
    in(err_a, (n32f_context': bitstring, msg_id: nat));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send error notification *)
    out(n32c, (sepp_b_addr, n32f_context, msg_id));

    (* receive confirmation *)
    in(n32c, (
        =sepp_a_addr, =n32f_context, =msg_id, status_code: bitstring
    ));
    event sendErrorSeppA(n32f_context, msg_id, status_code).
\end{lstlisting}

Listing~\ref{lst:n32c-error-recv} contains the receiving part of the error signaling procedure.
After receiving an error signaling message from its peer on N32-c, the \gls{sepp} retrieves the locally stored session parameters, based on the N32-f context ID.

The \gls{sepp} performs a validation of the received message ID, checking whether it is lower than or equal to the locally maintained message counter.
This ensures a previous message with the same id has indeed been sent previously.
A confirmation message including status code is signaled back to the peer \gls{sepp} over N32-c.
If above-mentioned check is successful, this status code is the constant {\sffamily SUCC}, else {\sffamily FAIL}.

\begin{lstlisting}[caption={Definition of the receiving error signaling process},label={lst:n32c-error-recv},firstnumber=573]
let N32cRecvErrorSeppA(sepp_a_addr: bitstring)=
    in(n32c, (
        =sepp_a_addr, n32f_context': bitstring, msg_id: nat
    ));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send confirmation *)
    if msg_id <= msg_cnt_a then
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, SUCC));
        event recvErrorSeppA(n32f_context, msg_id, SUCC)
    )
    else
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, FAIL));
        event recvErrorSeppA(n32f_context, msg_id, FAIL)
    ).
\end{lstlisting}

\subsection{N32-f Processes}

Prior to any inter-operator signaling, an \gls{nf} has to initiate an \gls{http} request towards a recipient in a foreign network.
Listing \ref{lst:nf-request} shows the process of an \gls{nf} in \gls{plmn} A creating a fresh message, compiling it into an \gls{http} request including source address, destination address, and message type ({\sffamily REQ}) before sending it to its local \gls{sepp} over the {\sffamily plmn\_a} channel.
The actual information sent to the \gls{sepp} is a tuple of the message direction ({\sffamily SEND}) and the \gls{http} message itself.
While the former is not necessary in real-world implementations, it prevents messages being erroneously consumed from the \gls{nf} response process displayed in the next listing.

\begin{lstlisting}[caption={Definition of the requesting NF process},label={lst:nf-request},firstnumber=751]
let NfARequest(nf_a_addr: bitstring, nf_b_addr: bitstring)=
    new msg_body: bitstring;
    let http_message =
        createHttp(nf_a_addr, nf_b_addr, REQ, msg_body) in
    event sendHttpMsgNfA(REQ, msg_body);
    out(plmn_a, (SEND, http_message)).
\end{lstlisting}

The \gls{nf} response process shown in listing~\ref{lst:nf-respond} expects an incoming \gls{http} message.
The equality sign before the constant {\sffamily RECV} is a shorthand for the validation of the message direction parameter.
In this case, only tuples consisting of the constant {\sffamily RECV} and a variable of type {\sffamily http} will be consumed by the process.

Subsequently, the \gls{http} message is deconstructed into its original components.
The action of the \gls{nf} varies depending on the contained message type.
If the message received is a request, a response is being sent that contains the same message body.
Otherwise, only an event is triggered indicating the receipt of an \gls{http} response.

\begin{lstlisting}[caption={Definition of the responding NF process},label={lst:nf-respond},firstnumber=758]
let NfAResponse(nf_a_addr: bitstring, nf_b_addr: bitstring)=
    in(plmn_a, (=RECV, msg: http));
    let createHttp(nf_b_addr: bitstring,
        =nf_a_addr,
        msg_type: bitstring,
        msg_body: bitstring) = msg in
    if msg_type = REQ then
    (
        event sendHttpMsgNfA(RES, msg_body);
        out(plmn_a, (SEND, createHttp(nf_a_addr, nf_b_addr, RES,msg_body)))
    )
    else event recvHttpMsgNfA(RES, msg_body).
\end{lstlisting}

Listing~\ref{lst:n32f-send} shows the sending N32-f process, i.e. the process in which signaling data is actually transferred.
Initially, an outbound \gls{http} message is consumed on the channel between local \gls{plmn} channel, marked by the {\sffamily SEND} flag in the input operation.
After retrieving a N32-f session context, said \gls{http} message is deconstructed into its original contents using the {\sffamily createHttp} data constructor.
This yields the message body which is used in combination with the stored encryption policies to determine confidential and non-confidential message parts.

Next, the message is assigned a unique identifier by incrementing the locally maintained message counter.
Together with other nonconfidential message parts serving as additional authenticated data, it is combined into a single structure using the constructor {\sffamily combineAAD}.
Prior to the encryption operation, the correct session key and nonce are determined based on the type of the \gls{http} message transported ({\sffamily REQ} or {\sffamily RES}).

The encryption function {\sffamily aeadEncrypt} uses the session key, the nonce, the confidential parts of the signaling message, and the \gls{aad} to produce the encrypted message content ({\sffamily payload}) and a \gls{jwe} tag required for authentication.
These information are supplemented by the destination address of the receiving \gls{sepp} as shown in figure \ref{fig:n32f-message} and then sent on the public N32-f channel.
Lastly, the locally stored N32-f context is updated to reflect the incremented message counter.

\begin{lstlisting}[caption={Definition of the sending N32-f signaling transmission process},label={lst:n32f-send},firstnumber=797]
let N32fSendSeppA()=
    in(plmn_a, (=SEND, http_message: http));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in

    (* rewrite http message *)
    let createHttp(source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        msg_body: bitstring) = http_message in
    event recvHttpMsgSeppA(msg_type, msg_body);
    let conf: bitstring = getConf(msg_body, encp_a) in
    let nonconf: bitstring = getNonconf(msg_body, encp_a) in

    let msg_id: nat = msg_cnt_a + 1 in
    let associated_data = combineAAD(
        source_addr, destination_addr, msg_type,
        nonconf, msg_id, ipx_a_id, n32f_context
    ) in

    (* determine session key & nonce *)
    let key = (if msg_type = REQ then
        par_req_key_a else
        par_res_key_a) in
    let nonce = (if msg_type = REQ then
        deriveNonce(par_req_iv_a, msg_id) else
        deriveNonce(par_res_iv_a, msg_id)) in

    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        key,
        nonce,
        conf,
        associated_data
    ) in
    event sendN32fMsgSeppA(n32f_context, msg_id, conf, nonconf);
    out(n32f_a, (sepp_b_addr, prins'(
        ciphers_a, nonce, associated_data, payload, jwe_tag
    )));
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).
\end{lstlisting}

The receiving part of N32-f signaling is modeled by the process in listing~\ref{lst:n32f-recv}.
The \gls{sepp} initially awaits a modified \gls{prins} message with a destination address that matched its own.
Note, that even if none of the intermediate \gls{ipx} providers is required to make changes to a N32-f message, they are still be expected to each create an empty \gls{json} patch and sign it - hence the expected data type {\sffamily modprins}.

Next, the received message is decomposed into its original components written by the sending \gls{sepp} and the two added patches using the data constructor {\sffamily prins''}.
The \gls{aad} object is further broken down to access non-confidential parts of the original message as well as the N32-f message ID, the identity of the authorized \gls{ipx}, and the related N32-f context.
The latter is required right afterwards to look-up the matching session context in local storage.

Similarly to the sending process, the receiving side also has to determine the session key and nonce based on the \gls{http} message type, before performing the decryption.
The following destructor {\sffamily aeadDecrypt}, requires these two parameter as well as the encrypted payload, the \gls{jwe} tag, and the \gls{aad} object in order to perform the decryption.
If successful, it yields the confidential parts of the original N32-f signaling message.

Afterwards, the first \gls{json} patch is validated by checking whether its origin is the same as specified by the sending \gls{sepp} in parameter {\sffamily auth\_ipx\_id}, by ensuring the operations are part of the modification policy, and by validating the contained \gls{jwe} tag is the same as the one in the original message.
All three checks are performed during decomposition of the {\sffamily ipxmod} object by matching them against the expected values.
Subsequently, the validity of the \gls{jws} object is checked using the constructor {\sffamily validPrinsSign}.
If all four checks pass successfully, the patch is considered valid, else invalid, and the relevant information is sent on the previously mentioned error signaling channels.
The modification of the patch by the second \gls{ipx} provider is omitted in the listing below for brevity.
Validation happens in the exact same way with one minor deviation: Instead of validating the source of the \gls{json} patch against the authorized \gls{ipx} identifier specified by the sending \gls{sepp}, it is compared against the identifier of the second \gls{ipx} provider on the path, which is locally stored in the N32-f context.

Lastly, if both \gls{json} patch validations succeed, the message as a whole is considered valid.
In this case, the constructor {\sffamily applyPatches} is used to incorporate the changes added by \gls{ipx} providers into the final message.
The updated message contents are rewritten into a new \gls{http} message and sent towards the receiving \gls{nf} in the \gls{sepp}'s own \gls{plmn}.

\lstset{escapeinside=~~}
\begin{lstlisting}[caption={Definition of the receiving N32-f signaling transmission process},label={lst:n32f-recv},firstnumber=846]
let N32fRecvSeppA(sepp_a_addr: bitstring)=
    in(n32f_a, (=sepp_a_addr, prins_messsage: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        nonce: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id: bitstring,
        n32f_context': bitstring
    ) = dataToIntegrityProtect in

    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* determine session key & nonce *)
    let key = (if msg_type = REQ then
        rev_req_key_a else
        rev_res_key_a) in
    let nonce = (if msg_type = REQ then
        deriveNonce(rev_req_iv_a, msg_id) else
        deriveNonce(rev_res_iv_a, msg_id)) in

    let conf = aeadDecrypt(
        key,
        nonce,
        (dataToIntegrityProtectAndCipher, jwe_tag),
        dataToIntegrityProtect
    ) in
    event recvN32fMsgSeppA(n32f_context', msg_id, conf, nonconf);

    (* verify ipx b json patch *)
    let jsonPatch(
        =modp_b,
        =auth_ipx_id,
        =jwe_tag,
        ipx_b_jws: bitstring
    ) = ipx_b_mods in
    if not(validPrinsSign(ipx_b_jws, ipx_b_key)) then
    (
        event recvInvalIpxPatchSeppA(
            auth_ipx_id, n32f_context, msg_id, jwe_tag, ipx_b_mods
        );
        out(err_a, (n32f_context, msg_id))
    )
    else
        event recvValidIpxPatchSeppA(
            auth_ipx_id, n32f_context, msg_id, jwe_tag, ipx_b_mods
        );
    ~\Suppressnumber~

    (* validation of second patch omitted *)
    ~\Reactivatenumber{703}~

    (* all patches valid *)
    if validPrinsModSign(ipx_a_jws, ipx_a_key) &&
        validPrinsSign(ipx_b_jws, ipx_b_key) &&
        policyValidation(nonconf, encp_a) then
    let msg_body = applyPatches((conf, nonconf), modp_b, modp_a) in
    let http_message = createHttp(
        source_addr,
        destination_addr,
        msg_type,
        msg_body) in
    event sendHttpMsgSeppA(msg_type, msg_body);
    out(plmn_a, (RECV, http_message)).
\end{lstlisting}

\subsection{IPX Processes}

As with the \glspl{sepp}, the two directly connected intermediaries providers are modeled separately as \gls{ipx} A and \gls{ipx} B.
Listing~\ref{lst:ipx-send} shows the process of \gls{ipx} A receiving a message from its peer \gls{sepp}, applying the first \gls{json} patch and then sending it on to the next \gls{ipx} provider.

After receiving the N32-f message, it is decomposed into its individual parts.
This operation, among other information, yields the \gls{jwe} tag required for writing legitimate message modifications.
Lines 838-840 show how the message operations (i.e. the modifications itself), the \gls{ipx} provider ID, the \gls{jwe} tag, and a \gls{jws} signature of the complete message are combined to form this patch.

The following decomposition of the \gls{aad} object solely serves the purpose of accessing the N32-f context ID and the message ID used by event {\sffamily ipxSendA} at the end of the process.
Section \ref{sec:verification} describes how this information is used for verification.
Afterwards, the \gls{ipx} provider's patch is combined with the original message contents in lines 851-859 to form a modified \gls{prins} message of type {\sffamily modprins}.
Note, that there is an additional, empty \gls{json} patch written by this first \gls{ipx} provider.
This is done to simplify the model by not creating a separate data-type for a modified \gls{prins} message with a single \gls{json} patch.
Finally, the modified message is sent towards the next \gls{ipx} provider.

\begin{lstlisting}[caption={Definition of the sending IPX process},label={lst:ipx-send},firstnumber=1101]
let N32fSendIpxA(id: bitstring, privkey_ipx_a: privkey, ops: bitstring)=
    in(n32f_a, (sepp_b_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey_ipx_a)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        =id,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    event ipxSendA(n32f_context, msg_id, jwe_tag, modifications);
    out(n32f_i, (sepp_b_addr, modified_message)).
\end{lstlisting}

Listing~\ref{lst:ipx-recv} shows the process of \gls{ipx} A receiving a N32-f message from the \gls{ipx} network that is to be forwarded to its directly connected \gls{sepp}.
The actions performed are largely the same as in the sending process above, the difference being that this time, an already modified \gls{prins} message is received on the interface between \gls{ipx} providers.
Further, the empty \gls{json} patch inserted by the previous \gls{ipx} provider is replaced before forwarding the updated message to the receiving \gls{sepp}.

\begin{lstlisting}[caption={Definition of the receiving IPX process},label={lst:ipx-recv},firstnumber=1142]
let N32fRecvIpxA(id: bitstring, privkey_ipx_a: privkey, ops: bitstring)=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        =EMPTY
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey_ipx_a)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    event ipxRecvA(n32f_context, msg_id, jwe_tag, modifications);
    out(n32f_a, (sepp_a_addr, modified_message)).
\end{lstlisting}

\subsection{Main process}

Listing~\ref{lst:main-proc} shows how the main process of the \textsc{ProVerif} model is defined.
This is where the previously described processes are combined in a way that models the overall protocol flow.
For brevity, the definition of variables, such as idientifiers for \gls{sepp} and \gls{ipx} nodes, cryptographic keys, and protection policies, have been omitted.

The execution is structured into six separate phases using the keyword {\sffamily sync}.
As noted in section~\ref{sec:formal}, \textsc{ProVerif} synchronization points ensure that processes are executed in a particular order -- according to the integer specified behind the {\sffamily sync} keyword.
Beyond that, all individual processes are combined using the pipe operator ,,~{\sffamily |}~'', denoting parallel execution.
Hence, processes in one synchronization group are run together and have to terminate successfully before the process continues with the next synchronization group.
Processes are not forcefully terminated preemptively.

Processes that are not specifically marked with {\sffamily sync} run in the default synchronization group~0.
In the created \gls{prins} model this group comprises all N32-c processes necessary to establish a connection between the two \glspl{sepp}.
Information passed to these processes include \gls{plmn} IDs, \gls{sepp} addresses as well as the session parameters ciphersuites, protection policies and \gls{ipx} provider information.
All of these information are expected to be preconfigured and remain unchanged in communication with one peer \gls{sepp} over one particular \gls{ipx} provider.
In contrast to the rest of the model, the subprocesses comprising the initial N32-c handshake is executed only once by each communicating party.
This is to ensure each possible role of a \gls{sepp} --i.e. initiating and responding to a N32-c session establishment-- is covered, while simultaneously reducing complexity for the rest of the verification by ensuring there is at most two active sessions stored in each of the \glspl{sepp}.

Synchronization group~1 (lines 1536-1539) contains the set of processes relevant for creating a new \gls{http} Request in each of the \glspl{plmn} any sending it via N32-f.
That is, processes of sending \glspl{nf} and sending \glspl{sepp} on both sides of the inter-operator communication.
The \gls{nf} processes {\sffamily NfARequest} and {\sffamily NfBRequest} each consume the source and destination address of the message to be created.
While in real world deloyments, operators would likely choose to not reveal the \gls{ip} addresses of their Network Functions and instead provide their partner networks with \glspl{fqdn}, this does not make a difference for the purposes of the \gls{prins} verification.
The \gls{sepp} processes {\sffamily N32fSendSeppA} and {\sffamily N32fSendSeppB} do not consume any parameters, instead retrieving all necessary information from the previously established N32-f process.
Starting from this synchronization group, each process is denoted with a preceeding exclamation mark operator ,,~{\sffamily !}~''.
This instructs \textsc{ProVerif} to spawn multiple instances of a given process.
By doing so, it is ensured more than one \gls{prins} message can be transferred between the two networks.
Furthermore, the tool is able to check for potential security flaws due to confusion of N32 sessions by any of the legitimate participants.

Synchronization group~2 (lines 1541-1549) comprises all \gls{ipx} processes to transport the previously created N32-f messages.
This includes sending and receiving processes by both well-behaving \gls{ipx} providers A and B as well as \gls{ipx} providers R1 and R2 intentionally violating the protocol.
Chapter \ref{chap:verification} further explains how these processes are used to explicitly check some security properties of \gls{prins}.
Each of these processes consumes an \gls{ipx} provider ID and a private key, required to create and sign \gls{json} patches for message modifications as well as the modifications itself.
The model assumes that information about the modifications to be performed has been exchanged between the \gls{ipx} provider and its directly connected \gls{sepp} out of band before session establishment and thus, is provided directly to the \gls{ipx} processes.

Synchronization group~3 (lines 1551-1560) captures the receiving processes of \glspl{sepp} and \glspl{nf}, sending processes of both \glspl{sepp} in order to transmit responses to the incoming requests, as well as N32-c error handling processes.
The receiving \gls{sepp} processes {\sffamily N32fRecvSeppA} and {\sffamily N32fRecvSeppB} consume their own address in order to identify incoming N32-f messages directed at them from other messages sent by the same \gls{sepp}.
The same applies to the error handling processes {\sffamily N32cSendErrorSeppA} and {\sffamily N32cSendErrorSeppB} as well as {\sffamily N32cRecvErrorSeppA} and {\sffamily N32cRecvErrorSeppB}.
The \gls{nf} processes {\sffamily NfAResponse} and {\sffamily NfBResponse}, just as the request processes, consume source and destination addresses of the message to be created in response.

Synchronization group~4 and 5 mirror group.~2 and 3 in that the response messages created during the previous phase are transmitted via the \gls{ipx} providers and received by the peer elements.
The only exception in synchronization group~5 is that no response is being sent following the receipt of a response message. Hence, sending \gls{sepp} processes are omitted.

\begin{lstlisting}[caption={Definition of the main process},label={lst:main-proc},firstnumber=1521]
    (* process execution *)
    (
        (N32cSendHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
        (N32cRecvHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (N32cSendHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (N32cRecvHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |

        (sync 1; !NfARequest(nf_a_addr, nf_b_addr)) |
        (sync 1; !NfBRequest(nf_b_addr, nf_a_addr)) |
        (sync 1; !N32fSendSeppA()) |
        (sync 1; !N32fSendSeppB()) |

        (sync 2; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 2; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 2; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 2; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 2; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 2; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
        (sync 2; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 2; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 2; !N32fRecvIpxR3()) |

        (sync 3; !N32fRecvSeppA(sepp_a_addr)) |
        (sync 3; !N32fRecvSeppB(sepp_b_addr)) |
        (sync 3; !NfAResponse(nf_a_addr, nf_b_addr)) |
        (sync 3; !NfBResponse(nf_b_addr, nf_a_addr)) |
        (sync 3; !N32cSendErrorSeppA(sepp_a_addr)) |
        (sync 3; !N32cRecvErrorSeppA(sepp_a_addr)) |
        (sync 3; !N32cSendErrorSeppB(sepp_b_addr)) |
        (sync 3; !N32cRecvErrorSeppB(sepp_b_addr)) |
        (sync 3; !N32fSendSeppA()) |
        (sync 3; !N32fSendSeppB()) |

        (sync 4; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 4; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 4; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 4; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (sync 4; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
        (sync 4; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
        (sync 4; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 4; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (sync 4; !N32fRecvIpxR3()) |

        (sync 5; !N32fRecvSeppA(sepp_a_addr)) |
        (sync 5; !N32fRecvSeppB(sepp_b_addr)) |
        (sync 5; !NfAResponse(nf_a_addr, nf_b_addr)) |
        (sync 5; !NfBResponse(nf_b_addr, nf_a_addr)) |
        (sync 5; !N32cSendErrorSeppA(sepp_a_addr)) |
        (sync 5; !N32cRecvErrorSeppA(sepp_a_addr)) |
        (sync 5; !N32cSendErrorSeppB(sepp_b_addr)) |
        (sync 5; !N32cRecvErrorSeppB(sepp_b_addr))
    )
\end{lstlisting}
