\subsection{Deliberate Abstractions}
\label{ssec:abstractions}

The \textsc{ProVerif} model of \gls{prins} described in the previous section necessarily abstracts away a number of details that have to be considered by real-world implementations.
In the following, these intentional abstractions and their implications on the verification of security properties are discussed.

\subsubsection{Perfectly Secure TLS \& Key Derivation}

As outlined before, this analysis solely focusses on the novel parts of the \gls{prins} protocol defined by \gls{3gpp}.
\gls{tls} is assumed to be perfectly secure and thus, is not modelled in detail.
Instead, \gls{tls}-based connections are represented by secure (i.e. confidential and integrity protected) channels shown in listing \ref{lst:channels}.
Since mutual authentication in N32-c communication crucially depends on the security of the transport layer, this model is not able to effectively validate this property of N32-c.

Another protocol aspect closely coupled with the \gls{tls} protocol is derivation of cryptographic key material during the N32-c handshake procedure.
According to the specification ,,two \glspl{sepp} shall export keying material from the \gls{tls} session established between them using the \gls{tls} export function'' (\cite{3gpp.33.501}, p. 132).
This export function produces a pseudorandom bitstring that is used to derive the various N32-f session keys outlined in section \ref{sec:n32}.
The model's N32-c channel being inherently secure by assumption, it is not possible to model a similar function producing fresh key material based on a shared, authenticated session.
This issue is being addressed, by the private constructor {\sffamily deriveMasterKey}, consuming the N32-f context ID.
This input parameter ensures that the resulting master key is unique to a specific N32-f session.
The attribute {\sffamily private} guarantees that this function is not be accessible to adversaries, so that even with possession of the N32-f context ID, it is not possible to derive the same cryptographic key.
This kind of substitution for the \gls{tls} export function is flawed in two ways. Firstly, it relies on the secrecy of the derivation function iteslf, rather than the secrecy of the input parameter.
Secondly, the attribute {\sffamily private} still allows the function to be used by all legitimate protocol participants.
In the created model, this also includes the \gls{ipx} processes.
However, these points do not impact verification of the protocol, as private \textsc{ProVerif} functions cannot be leaked and the honest \gls{ipx} processes do not make use of the function either.

Furthermore, the the model does not mirror the complete key hierarchy of the protocol
As noted in section \ref{sec:n32}, \gls{prins} distinguishes session keys based on the \gls{sepp}'s role during the initial N32-c handshake --parallel (i.e. initiating) or reverse (i.e. responding)-- and based on the nature of the transported signaling message -- \gls{http} request or response.
The model described in the previous chapter does not consider the contents of a signaling message.
It only distinguishes confidential and non-confidential information in an incoming \gls{http} message, regardless of it being a request or a response.
Hence, each \gls{sepp} only handles one parallel key, one reverse key ({\sffamily par\_key}, {\sffamily rev\_key}), one parallel \gls{iv} and one reverse \gls{iv} ({\sffamily par\_iv}, {\sffamily rev\_iv}).
This, too, does not impact the verification result, since the various session keys are merely used in different message contexts in the same processes.
If, for example, one of the processes in section \ref{sec:model} were to expose the session key for an outbound N32-f message containing an \gls{http} response, this would also be discovered in the case of an outbound N32-f message containing an \gls{http} request.

\subsubsection{Protection Policies}

\gls{prins} protection policies control what data-types are to be ciphered before being sent over the N32-f channel and which authenticated modifications may be performed on them.
Both types of protection policies are abstracted to single bitstrings in order to simplify related operations.

The data-type encryption policy plays a key role in rewriting \gls{http} messages received from \glspl{nf} in the \gls{sepp}'s own \gls{plmn}.
In the model, an \gls{http} message is split into a confidential and non-confidential message part using the deconstructor {\sffamily reformatHttp}, displayed in listing \ref{lst:n32f-rewriting}.
Using an encryption policy as a second argument, it enables honest participants to identify the information to be ciphered.
The alternative deconstructor {\sffamily reformatHttp'} is provided for completeness sake:
Given an \gls{http} message, adversaries are able to access both confidential and non-confidential message parts as well, without knowledge of the related encryption policy.

The the constructor {\sffamily reformatN32f} is used by the receiving \gls{sepp} to compile the individual parts back to an \gls{http} message.
This function on its own is unable to verify that the same data-type encryption policy has been used by the sending \gls{sepp}, as is required by the specification.
To substitute this check at the receiving end, the locally stored and the received data-type encryption policies are compared for equality during the initial N32-c handshake procedure.
This check ensures that both \glspl{sepp} shall apply consistent ciphering of information elements on N32-f.

\begin{lstlisting}[caption={N32-f message rewriting},label={lst:n32f-rewriting},firstnumber=105]
(* data-type encryption policy application *)
fun policyApplication(bitstring, bitstring): n32.
reduc forall m: bitstring, p: bitstring;
    policyValidation(policyApplication(m, p), p)) = true
otherwise forall m: bitstring, p: bitstring, p': bitstring;
    policyValidation(policyApplication(m, p), p')) = false
\end{lstlisting}

The bitstrings modelling the modification policies represent both the policies defined by either of the \gls{sepp} operators as well as the actual modifications written by intermediaty \gls{ipx} providers.
This allows a simple comparison of the operation contained inside the \gls{json} patch and the related policy itself to determine whether or not a given message modification is legitimate.
This does not impact the verification result, as it is logically the same as a policy containing exactly one entry.
If the protocol behaves as intended using this examplary modification policy, it behaves similarly for more complex examples.

\subsubsection{Message Rewriting}

The final step of \gls{prins} message rewriting, i.e. the application of the validated \gls{jose} patches is omitted from the model.
Since this procedure is performed internally to the receiving \gls{sepp}, i.e. no communication with other participants is required, there is no possibility of revealing any confidential information.
Related checks that do impact security properties of the protocol, such as the authentication of \gls{jose} patches and comparison with the modification policy, are validate prior to this step.
Hence, this protocol aspect can safely be omitted without compromising the verification result.

\subsubsection{Message Routing}

As mentioned in the previous section, inter-\gls{plmn} message routing, which would utilize \gls{ip} routing in real-world implementations, is simplified greatly by use of dedicated N32-c and N32-f channels.
Processes of sending \glspl{sepp} specify their communication peer by its address in outgouing messages.
This information is provided to avoid trivial loops between sending and receiving processes of the same \gls{sepp}:
Without any attribute identifying either part of the communication, an outgoing message could be consumed by the same \gls{sepp}'s receiving process without noticing that the message is its own.
Hence, in this model receiving \glspl{sepp} verify whether the identity specified in incoming messages matches their own and only proceed with processing the message if this condition is met.
Note that this does not preclude the verification of potential authentication flaws.
An adversary is, of course, still able to spoof the \gls{sepp} address value.
The check merely prevents the confusion of messages by honest \gls{sepp} processes.

Beyond that, the model does not consider any information identifying the source a message.
That is, at least on the N32-c channel, which is considered authenticated and confidential as explained previously.
As far as N32-f communication is concerned, the receiving \gls{sepp} is able to correlate an incoming message by its N32-f context ID to related information, such as session keys.
During the validation of the \gls{aad} contained in the message, the \gls{sepp} is able to implicitly verify the original message source.

\subsubsection{IPX Provider Internals}

Similarly to message routing from and to communicating \glspl{sepp}, message handling by \gls{ipx} providers is reduced to the bare minimum.
Each \gls{ipx} process utilizes two distinct N32-f channels, one towards its directly connected \gls{sepp} and another towards the second \gls{ipx} provider.
Every message received on one of these interfaces is forwarded on the other one after internal processing.

Modifications are signed using raw private keys, one of two options specified by the \gls{3gpp} specification for this purpose.
The alternative, i.e. a digital certificate issued by the operator of the directly connected \gls{sepp}, as well as the possibility for \gls{ipx} providers to use multiple cryptographic identities is not considered in the model.
Since there is no fundamental difference between the use of one or multiple keys and the asymmetric cryptography used in digital certificated is just the same as for raw private/public key pairs, this abstraction does not negatively impact the verification result.

\subsubsection{Parameter Renegotiation}

Renegotiation of session parameters is left out of scope of this work entirely.
Such procedure is required when existing session keys reach the end of their lifetime or any other preconfigured session parameter, such as the cipher suite to be used, changes.
Firstly, at the time of this writing the \gls{3gpp} specifications \gls{ts} 33.501 and \gls{ts} 29.573 do not clearly stipulate how a \gls{sepp} is to perform a renegotiation.
Secondly, the triggers that would necessitate this procedure, such as the timeout of cryptographic keys are not considered in the model either, for reasons described in the following section.

\subsection{Model Shortcomings}

\subsubsection{Invalidation of N32-f Keys \& Contexts}

Formal verification in general provides very limited support for expressing temporal relations.
While \textsc{ProVerif} allows for the verification of correspondence assertions, ensuring that certain events do or do not happen after other events, it does not allow to convey precise timings.
Hence, the model does not consider the limited lifetime of cryptographic keys associated with a N32-f context.

Furthermore, real-world protocol implementations relying on incremental counters, such as the message IDs used in N32-f communication, are forced to handle limits of integer values to avoid overflows.
At some point during protocol execution, session parameters have to be refreshed in order to prevent counter wrap around.
\textsc{ProVerif} does offer support for natural numbers, however, the concept of integer overflows is not reproduceble.

Lastly, \textsc{ProVerif} tables, which represent a convenient way of modelling local \gls{sepp} storage as shown in the previous sections, do not offer the possibility of deleting records.
While real-world implementations would invalidate N32-f contexts at certain events or specific points in time, the model is not able to reproduce this behavior.

\subsubsection{to be expanded...}