(* Custom type definitions *)

type key.
type mac.
type privkey.
type pubkey.
type prins.
type aad.
type ipxmod.


(* Free names / channels *)

free n32f_ati: channel. (* Channel between SEPP A and IPX A *)
free n32f_iti: channel. (* Channel between IPX A and IPX B *)
free n32f_bti: channel. (* Channel between IPX B and SEPP B *)
free n32c: channel [private].       (* Channel between SEPP A and SEPP B *)

(* Tables - private by default *)

table localStorageSeppA(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP A modification policy *)
                        bitstring,  (* SEPP B modification policy *)
                        pubkey,       (* IPX A public key *)
                        pubkey).      (* IPX B public key *)

table localStorageSeppB(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP B modification policy *)
                        bitstring,  (* SEPP A modification policy *)
                        pubkey,       (* IPX B public key *)
                        pubkey).      (* IPX A public key *)


(* Custom Functions *)

fun deriveMasterKey(bitstring): key [private].
fun deriveSessionKey(key): key.
fun deriveIV(key): bitstring.

(* Custom Constructors *)

fun createContextId(bitstring, bitstring): bitstring.

fun http(bitstring, bitstring): bitstring [data].

fun combineAAD(bitstring,                   (* DataToIntegrityProtect *)
                bitstring,                  (* Msg Id *)
                bitstring,                  (* Authorized IPX *)
                bitstring):aad [data].      (* N32f Context Id *)

fun jsonPatch(bitstring,                    (* Operations *)
                bitstring,                  (* IPX Id *)
                bitstring,                  (* JWE Tag *)
                bitstring):ipxmod [data].   (* JWS Signature *)

fun appendPatch(prins,                      (* Original N32f Message *)
            ipxmod): prins [data].          (* IPX A Patch *)

fun prins'(bitstring,                       (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            bitstring): prins [data].       (* JWE Tag *)

fun prins''(bitstring,                      (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            bitstring,                      (* JWE Tag *)
            ipxmod): prins [data].          (* IPX A Patch *)

fun prins'''(bitstring,                     (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            bitstring,                      (* JWE Tag *)
            ipxmod,                         (* IPX A Patch *)
            ipxmod): prins [data].          (* IPX B Patch *)

(* MAC *)
fun macf(bitstring, key): mac.
reduc forall m: bitstring, k: key; verify_mac(macf(m, k), m, k) = true.

(* Symmetric Encryption *)
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(* Signatures *)
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey; getmess(sign(m, k)) = m.
reduc forall m: bitstring, k: privkey; checksign(sign(m, k), pk(k)) = true.

fun signprins'(prins, bitstring, bitstring, bitstring, privkey): bitstring.
reduc forall p: prins, ops: bitstring, id: bitstring, tag: bitstring, k: privkey;
    checksignprins'(signprins'(p, ops, id, tag, k), pk(k)) = true.

(* AEAD Encryption *)
fun encrypt(bitstring, key, bitstring): bitstring.
reduc forall msg: bitstring, k: key, iv: bitstring;
    decrypt(encrypt(msg, k, iv), k, iv) = msg.

reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    AEAD_Encrypt(k, iv, payload, adata) = (
                                encrypt(payload, k, iv),
                                macf((iv, adata, encrypt(payload, k, iv)), k)
                                ).
reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    AEAD_Decrypt(k, iv, (encrypt(payload, k, iv), macf((iv, adata, encrypt(payload, k, iv)), k)), adata) = payload.


(* Queries *)

event agreedContextSendSeppA(bitstring).
event agreedContextRecvSeppA(bitstring).
event agreedContextSendSeppB(bitstring).
event agreedContextRecvSeppB(bitstring).
event agreedEncPolicySendSeppA(bitstring).
event agreedEncPolicyRecvSeppA(bitstring).
event agreedEncPolicySendSeppB(bitstring).
event agreedEncPolicyRecvSeppB(bitstring).
event agreedMasterKeySendSeppA(key).
event agreedMasterKeyRecvSeppA(key).
event agreedMasterKeySendSeppB(key).
event agreedMasterKeyRecvSeppB(key).

event recvAvalidIpxPatchA(ipxmod).
event recvAvalidIpxPatchB(ipxmod).
event recvBvalidIpxPatchA(ipxmod).
event recvBvalidIpxPatchB(ipxmod).

event ipxModAin(ipxmod).
event ipxModAout(ipxmod).
event ipxModBin(ipxmod).
event ipxModBout(ipxmod).

(* N32-f Context Ids equivalent *)
query n32f_cid_a: bitstring, n32f_cid_b: bitstring;
    event(agreedContextSendSeppA(n32f_cid_a)) && event(agreedContextRecvSeppB(n32f_cid_b))
    ==> n32f_cid_a = n32f_cid_b [induction].

query n32f_cid_a: bitstring, n32f_cid_b: bitstring;
    event(agreedContextSendSeppB(n32f_cid_b)) && event(agreedContextRecvSeppA(n32f_cid_a))
    ==> n32f_cid_b = n32f_cid_a [induction].

query n32f_cid_a: bitstring, n32f_cid_b: bitstring;
    event(agreedContextSendSeppB(n32f_cid_b)) && event(agreedContextRecvSeppA(n32f_cid_a))
    ==> n32f_cid_b = n32f_cid_a [induction].

(* Encryption policies equivalent *)
query encp_a: bitstring, encp_b: bitstring;
    event(agreedEncPolicySendSeppA(encp_a)) && event(agreedEncPolicyRecvSeppB(encp_b))
    ==> encp_a = encp_b [induction].

query encp_a: bitstring, encp_b: bitstring;
    event(agreedEncPolicySendSeppB(encp_b)) && event(agreedEncPolicyRecvSeppA(encp_a))
    ==> encp_b = encp_a [induction].

(* master keys equivalent *)
query master_key_a: key, master_key_b: key;
    event(agreedMasterKeySendSeppA(master_key_a)) && event(agreedMasterKeyRecvSeppB(master_key_b))
    ==> master_key_a = master_key_b [induction].

query master_key_a: key, master_key_b: key;
    event(agreedMasterKeySendSeppB(master_key_b)) && event(agreedMasterKeyRecvSeppA(master_key_a))
    ==> master_key_b = master_key_a [induction].

(* IPX modifications valid *)
query modp_a: ipxmod, modp_b: ipxmod;
    event(ipxModAout(modp_a)) && event(ipxModBin(modp_b))
    ==> event(recvBvalidIpxPatchA(modp_a)) && event(recvBvalidIpxPatchB(modp_b)).

query modp_a: ipxmod, modp_b: ipxmod;
    event(ipxModBout(modp_b)) && event(ipxModAin(modp_a))
    ==> event(recvAvalidIpxPatchA(modp_a)) && event(recvAvalidIpxPatchB(modp_b)).

free master_key_a, master_key_b, session_key_a, session_key_b: key [private].
free conf: bitstring [private].

query attacker(master_key_a);
      attacker(master_key_b).

query attacker(session_key_a);
      attacker(session_key_b).

noninterf master_key_a.
noninterf master_key_b.
weaksecret master_key_a.
weaksecret master_key_b.

query attacker(conf).



(* SEPP A N32-c Processes *)

let N32cSendSeppA(cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipxkey: pubkey)=
    (* create random N32-f precontext id *)
    new n32f_pid: bitstring;
    out(n32c, (cipher_suite, n32f_pid));
    in(n32c, (cs_b: bitstring, n32f_pid_b: bitstring));
    if cipher_suite = cs_b then
        (* create N32-f context from precontext ids *)
        let n32f_cid = createContextId(n32f_pid, n32f_pid_b) in
        event agreedContextSendSeppA(n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicySendSeppA(encp);
            out(n32c, ipxkey);
            in(n32c, ipxkey_b: pubkey);
            let master_key_a = deriveMasterKey(n32f_cid) in
            event agreedMasterKeySendSeppA(master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp, modp_b, ipxkey, ipxkey_b).

let N32cRecvSeppA(cipher_suite: bitstring, encp: bitstring, modp_a: bitstring, ipxkey: pubkey)=
    (* create random N32-f precontext id *)
    new n32f_pid: bitstring;
    in(n32c, (cs_b: bitstring, n32f_pid_b: bitstring));
    if cipher_suite = cs_b then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_b, n32f_pid) in
        (* Create N32-f context from precontext ids *)
        event agreedContextRecvSeppA(n32f_cid);
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicyRecvSeppA(encp);
            out(n32c, (encp, modp_a));
            in(n32c, ipxkey_b: pubkey);
            out(n32c, ipxkey);
            let master_key_a = deriveMasterKey(n32f_cid) in
            event agreedMasterKeyRecvSeppA(master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp_a, modp_b, ipxkey, ipxkey_b).


(* SEPP B N32-c Processes *)

let N32cSendSeppB(cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipxkey: pubkey)=
    new n32f_pid: bitstring;
    out(n32c, (cipher_suite, n32f_pid));
    in(n32c, (cs_a: bitstring, n32f_pid_a: bitstring));
    if cipher_suite = cs_a then
        let n32f_cid = createContextId(n32f_pid, n32f_pid_a) in
        event agreedContextSendSeppB(n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicySendSeppB(encp);
            out(n32c, ipxkey);
            in(n32c, ipxkey_a: pubkey);
            let master_key_b = deriveMasterKey(n32f_cid) in
            event agreedMasterKeySendSeppB(master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipxkey, ipxkey_a).

let N32cRecvSeppB(cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipxkey: pubkey)=
    new n32f_pid: bitstring;
    in(n32c, (cs_a: bitstring, n32f_pid_a: bitstring));
    if cipher_suite = cs_a then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_a, n32f_pid) in
        event agreedContextRecvSeppB(n32f_cid);
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicyRecvSeppB(encp);
            out(n32c, (encp, modp));
            in(n32c, ipxkey_a: pubkey);
            out(n32c, ipxkey);
            let master_key_b = deriveMasterKey(n32f_cid) in
            event agreedMasterKeyRecvSeppB(master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipxkey, ipxkey_a).


(* SEPP A N32-f Processes *)

let N32fSendSeppA(http_message: bitstring, auth_ipx_id: bitstring)=
    let http(nonconf, conf) = http_message in
        new message_id: bitstring;
        get localStorageSeppA(n32f_context, session_key, iv, cipher_suite, encp, modp_a, modp_b, ipxkey_a, ipxkey_b) in
        let associated_data = combineAAD(nonconf, message_id, auth_ipx_id, n32f_context) in
            let (payload: bitstring, jwe_tag: bitstring) = AEAD_Encrypt(
                    session_key,
                    iv,
                    conf,
                    associated_data
                ) in
            out(n32f_ati, prins'(cipher_suite, iv, associated_data, payload, jwe_tag)).

let N32fRecvSeppA()=
    in(n32f_bti, prins_messsage: prins);
    let prins'''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipx_mods_b: ipxmod,
        ipx_mods_a: ipxmod) = prins_messsage in
    get localStorageSeppB(n32f_context, session_key, iv, cipher_suite, encp, modp_b, modp_a, ipxkey_b, ipxkey_a) in
    let conf = AEAD_Decrypt(
        session_key,
        iv,
        dataToIntegrityProtectAndCipher,
        dataToIntegrityProtect) in

    let jsonPatch(
        ops_b: bitstring,
        ipx_b_id: bitstring,
        jwe_tag_b: bitstring,
        jws_signature_b: bitstring) = ipx_mods_b in
        if checksignprins'(jws_signature_b, ipxkey_b) && jwe_tag_b = jwe_tag then
            event recvAvalidIpxPatchB(ipx_mods_b);

    let jsonPatch(
        ops_a: bitstring,
        ipx_a_id: bitstring,
        jwe_tag_a: bitstring,
        jws_signature_a: bitstring) = ipx_mods_a in
        if checksignprins'(jws_signature_a, ipxkey_a) && jwe_tag_a = jwe_tag then
            event recvAvalidIpxPatchA(ipx_mods_a).


(* SEPP B N32-f Processes *)

let N32fSendSeppB(http_message: bitstring, auth_ipx_id: bitstring)=
    let http(nonconf, conf) = http_message in
        new message_id: bitstring;
        get localStorageSeppA(n32f_context, session_key, iv, cipher_suite, encp, modp_b, modp_a, ipxkey_b, ipxkey_a) in
        let associated_data = combineAAD(nonconf, message_id, auth_ipx_id, n32f_context) in
            let (payload: bitstring, jwe_tag: bitstring) = AEAD_Encrypt(
                    session_key,
                    iv,
                    conf,
                    associated_data
                ) in
            out(n32f_bti, prins'(cipher_suite, iv, associated_data, payload, jwe_tag)).

let N32fRecvSeppB()=
    in(n32f_bti, prins_messsage: prins);
    let prins'''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipx_mods_a: ipxmod,
        ipx_mods_b: ipxmod) = prins_messsage in
    get localStorageSeppB(n32f_context, session_key, iv, cipher_suite, encp, modp_b, modp_a, ipxkey_b, ipxkey_a) in
    let conf = AEAD_Decrypt(
        session_key,
        iv,
        dataToIntegrityProtectAndCipher,
        dataToIntegrityProtect) in

    let jsonPatch(
        ops_a: bitstring,
        ipx_a_id: bitstring,
        jwe_tag_a: bitstring,
        jws_signature_a: bitstring) = ipx_mods_a in
        if checksignprins'(jws_signature_a, ipxkey_a) && jwe_tag_a = jwe_tag then
            event recvBvalidIpxPatchA(ipx_mods_a);

    let jsonPatch(
        ops_b: bitstring,
        ipx_b_id: bitstring,
        jwe_tag_b: bitstring,
        jws_signature_b: bitstring) = ipx_mods_b in
        if checksignprins'(jws_signature_b, ipxkey_b) && jwe_tag_b = jwe_tag then
            event recvBvalidIpxPatchB(ipx_mods_b).


(* IPX A Process *)

let N32fSendIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_ati, (prins_message: prins));
    let prins'(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                            signprins'(prins_message, ops, id, jwe_tag, privkey)) in
        event ipxModAout(modifications);
        out(n32f_iti, appendPatch(prins_message, modifications)).

let N32fRecvIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: prins));
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipxModificationsB: ipxmod) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                            signprins'(prins_message, ops, id, jwe_tag, privkey)) in
        event ipxModAin(modifications);
        out(n32f_ati, appendPatch(prins_message, modifications)).

(* IPX B Process *)

let N32fSendIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_bti, (prins_message: prins));
    let prins'(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                            signprins'(prins_message, ops, id, jwe_tag, privkey)) in
        event ipxModBout(modifications);
        out(n32f_iti, appendPatch(prins_message, modifications)).

let N32fRecvIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: prins));
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipxModificationsA: ipxmod) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                            signprins'(prins_message, ops, id, jwe_tag, privkey)) in
        event ipxModBin(modifications);
        out(n32f_ati, appendPatch(prins_message, modifications)).


(* Main Process *)

process
    new sepp_a_privkey: privkey; new sepp_b_privkey: privkey;
    new ciphersuites_a: bitstring; new ciphersuite_b: bitstring;
    new encp_a: bitstring; new encp_b: bitstring;
    new modp_a: bitstring; new modp_b: bitstring;
    new ipx_a_id: bitstring; new ipx_b_id: bitstring;
    new ipx_a_privkey: privkey; new ipx_b_privkey: privkey;
    new message: bitstring;

    (* Create key pairs & publish public keys *)
    let ipx_a_pubkey = pk(ipx_a_privkey) in out(n32f_ati, ipx_a_pubkey);
    let ipx_b_pubkey = pk(ipx_b_privkey) in out(n32f_ati, ipx_b_pubkey);
    let sepp_a_pubkey = pk(sepp_a_privkey) in out(n32f_ati, sepp_a_pubkey);
    let sepp_b_pubkey = pk(sepp_b_privkey) in out(n32f_ati, sepp_b_pubkey);

    (N32cSendSeppA(ciphersuites_a, encp_a, modp_a, ipx_a_pubkey)) |
    (N32cSendSeppB(ciphersuite_b, encp_b, modp_b, ipx_b_pubkey)) |
    (N32cRecvSeppA(ciphersuites_a, encp_a, modp_a, ipx_a_pubkey)) |
    (N32cRecvSeppB(ciphersuite_b, encp_b, modp_b, ipx_b_pubkey)) |
    (phase 1; N32fSendSeppA(message, modp_a)) |
    (N32fSendSeppB(message, modp_b)) |
    (N32fRecvSeppA()) |
    (N32fRecvSeppB()) |
    (N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b))