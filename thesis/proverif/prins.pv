(* custom type definitions *)

type key.
type mac.
type privkey.
type pubkey.
type prins.
type modprins.
type aad.
type ipxmod.


(* free names / channels *)

free n32f_ati: channel.             (* Channel between SEPP A and IPX A *)
free n32f_iti: channel.             (* Channel between IPX A and IPX B *)
free n32f_bti: channel.             (* Channel between IPX B and SEPP B *)
free n32c: channel [private].       (* Channel between SEPP A and SEPP B *)
const empty: ipxmod.

(* tables - private by default *)

table localStorageSeppA(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP A modification policy *)
                        bitstring,  (* SEPP B modification policy *)
                        bitstring,  (* IPX A id *)
                        pubkey,     (* IPX A public key *)
                        bitstring,  (* IPX B id *)
                        pubkey).    (* IPX B public key *)

table localStorageSeppB(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP B modification policy *)
                        bitstring,  (* SEPP A modification policy *)
                        bitstring,  (* IPX B id *)
                        pubkey,     (* IPX B public key *)
                        bitstring,  (* IPX A id *)
                        pubkey).    (* IPX A public key *)


(* custom functions *)

fun deriveMasterKey(bitstring): key [private].
fun deriveSessionKey(key): key.
fun deriveIV(key): bitstring.

(* custom constructors *)

fun createContextId(bitstring, bitstring): bitstring.

fun combineAAD(bitstring,                   (* DataToIntegrityProtect *)
                bitstring,                  (* Msg Id *)
                bitstring,                  (* Authorized IPX *)
                bitstring):aad [data].      (* N32f Context Id *)

fun jsonPatch(bitstring,                    (* Operations *)
                bitstring,                  (* IPX Id *)
                mac,                        (* JWE Tag *)
                bitstring):ipxmod [data].   (* JWS Signature *)

fun prins'(bitstring,                       (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            mac): prins [data].             (* JWE Tag *)

fun prins''(bitstring,                      (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            mac,                            (* JWE Tag *)
            ipxmod,                         (* IPX A Patch *)
            ipxmod): modprins [data].       (* IPX B Patch *)

(* mac *)
fun macf(bitstring, key): mac.

(* symmetric encryption *)
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(* signatures *)
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey; getmess(sign(m, k)) = m.
reduc forall m: bitstring, k: privkey; checksign(sign(m, k), pk(k)) = true.

fun signprins(prins, bitstring, bitstring, mac, privkey): bitstring.
reduc forall p: prins, ops: bitstring, id: bitstring, tag: mac, k: privkey;
    checksignprins(signprins(p, ops, id, tag, k), pk(k)) = true.
fun signmodprins(modprins, bitstring, bitstring, mac, privkey): bitstring.
reduc forall p: modprins, ops: bitstring, id: bitstring, tag: mac, k: privkey;
    checksignmodprins(signmodprins(p, ops, id, tag, k), pk(k)) = true.

(* aead encryption *)
fun encrypt(bitstring, key, bitstring): bitstring.
reduc forall msg: bitstring, k: key, iv: bitstring;
    decrypt(encrypt(msg, k, iv), k, iv) = msg.

reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadEncrypt(k, iv, payload, adata) = (
                                encrypt(payload, k, iv),
                                macf((iv, adata, encrypt(payload, k, iv)), k)
                                ).
reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadDecrypt(k,
                iv,
                (encrypt(payload, k, iv), macf((iv, adata, encrypt(payload, k, iv)), k)), adata
                ) = payload.


(* queries *)

event agreedContextSendSeppA(bitstring, bitstring).
event agreedContextRecvSeppA(bitstring, bitstring).
event agreedContextSendSeppB(bitstring, bitstring).
event agreedContextRecvSeppB(bitstring, bitstring).
event agreedEncPolicySendSeppA(bitstring, bitstring).
event agreedEncPolicyRecvSeppA(bitstring, bitstring).
event agreedEncPolicySendSeppB(bitstring, bitstring).
event agreedEncPolicyRecvSeppB(bitstring, bitstring).
event agreedMasterKeySendSeppA(bitstring, key).
event agreedMasterKeyRecvSeppA(bitstring, key).
event agreedMasterKeySendSeppB(bitstring, key).
event agreedMasterKeyRecvSeppB(bitstring, key).

event sendSeppA(bitstring, bitstring, bitstring, bitstring).
event recvSeppA(bitstring, bitstring, bitstring, bitstring).
event sendSeppB(bitstring, bitstring, bitstring, bitstring).
event recvSeppB(bitstring, bitstring, bitstring, bitstring).

event recvAvalidIpxPatchA(bitstring, mac, ipxmod).
event recvAvalidIpxPatchB(bitstring, mac, ipxmod).
event recvBvalidIpxPatchA(bitstring, mac, ipxmod).
event recvBvalidIpxPatchB(bitstring, mac, ipxmod).

event sendKeyUpdateSeppA(key).
event recvKeyUpdateSeppA(key).
event sendKeyUpdateSeppB(key).
event recvKeyUpdateSeppB(key).

event ipxRecvA(bitstring, mac, ipxmod).
event ipxSendA(bitstring, mac, ipxmod).
event ipxRecvB(bitstring, mac, ipxmod).
event ipxSendB(bitstring, mac, ipxmod).

(* secrecy queries *)

free master_key_a, master_key_b, session_key_a, session_key_b: key [private].
free msg_a_conf, msg_b_conf: bitstring [private].
free msg_a_nonconf, msg_b_nonconf: bitstring.

query attacker(master_key_a);
      attacker(master_key_b).
query attacker(session_key_a);
      attacker(session_key_b).
query attacker(msg_a_conf);
      attacker(msg_b_conf).

(* sec property 5: strong secrecy of master/session keys *)
noninterf master_key_a.
noninterf master_key_b.
noninterf session_key_a.
noninterf session_key_b.

query nonce: bitstring, n32f_context_a: bitstring, n32f_context_b: bitstring;
    event(agreedContextSendSeppA(nonce, n32f_context_a)) &&
    event(agreedContextRecvSeppB(nonce, n32f_context_b)) ==>
    n32f_context_a = n32f_context_b;
    event(agreedContextSendSeppB(nonce, n32f_context_b)) &&
    event(agreedContextRecvSeppA(nonce, n32f_context_a)) ==>
    n32f_context_b = n32f_context_a.

(* sec property 3: master keys equivalent *)
query n32f_cid: bitstring;
    event(agreedMasterKeySendSeppA(n32f_cid, master_key_a)) &&
    event(agreedMasterKeyRecvSeppB(n32f_cid, master_key_b)) ==>
    master_key_a = master_key_b;
    event(agreedMasterKeySendSeppB(n32f_cid, master_key_b)) &&
    event(agreedMasterKeyRecvSeppA(n32f_cid, master_key_a)) ==>
    master_key_b = master_key_a.

(* sec property 4: master keys equivalent *)
query n32f_cid: bitstring;
    event(agreedMasterKeySendSeppA(n32f_cid, master_key_a)) &&
    event(agreedMasterKeyRecvSeppB(n32f_cid, master_key_b)) ==>
    master_key_a = master_key_b;
    event(agreedMasterKeySendSeppB(n32f_cid, master_key_b)) &&
    event(agreedMasterKeyRecvSeppA(n32f_cid, master_key_a)) ==>
    master_key_b = master_key_a.

(* sec property 6/7: integrity protection *)
query n32f_context: bitstring, msg_id: bitstring;
    event(sendSeppA(n32f_context, msg_id, msg_a_conf, msg_a_nonconf)) &&
    event(recvSeppB(n32f_context, msg_id, msg_b_conf, msg_b_nonconf)) ==>
    msg_a_conf = msg_b_conf &&
    msg_a_nonconf = msg_b_nonconf;
    event(sendSeppB(n32f_context, msg_id, msg_b_conf, msg_b_nonconf)) &&
    event(recvSeppA(n32f_context, msg_id, msg_a_conf, msg_a_nonconf)) ==>
    msg_a_conf = msg_b_conf &&
    msg_a_nonconf = msg_b_nonconf.

(* effective key update *)
query event(sendKeyUpdateSeppA(master_key_a)) && 
      event(recvKeyUpdateSeppB(master_key_b)) ==>
      master_key_a = master_key_b;
      event(sendKeyUpdateSeppB(master_key_b)) && 
      event(recvKeyUpdateSeppA(master_key_a)) ==>
      master_key_a = master_key_b.

(* SEPP A N32-c Processes *)

let N32cSendHandshakeSeppA(sepp_a_privkey: privkey, cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_a_id: bitstring, ipx_a_key: pubkey)=
    new n32f_pid: bitstring;
    new nonce: bitstring;
    let sig = sign(nonce, sepp_a_privkey) in
    out(n32c, (cipher_suite, n32f_pid, nonce, sig));
    in(n32c, (cipher_suite_b: bitstring, n32f_pid_b: bitstring));
    if cipher_suite = cipher_suite_b then
        let n32f_cid = createContextId(n32f_pid, n32f_pid_b) in
        event agreedContextSendSeppA(nonce, n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicySendSeppA(n32f_cid, encp);
            out(n32c, (ipx_a_id, ipx_a_key));
            in(n32c, (ipx_b_id: bitstring, ipx_b_key: pubkey));
            let master_key_a = deriveMasterKey(nonce) in
            event agreedMasterKeySendSeppA(n32f_cid, master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key).

let N32cRecvHandshakeSeppA(sepp_b_pubkey: pubkey, cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_a_id: bitstring, ipx_a_key: pubkey)=
    new n32f_pid: bitstring;
    in(n32c, (cipher_suite_b: bitstring, n32f_pid_b: bitstring,
            nonce: bitstring, sig: bitstring));
    if checksign(sig, sepp_b_pubkey) && cipher_suite = cipher_suite_b then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_b, n32f_pid) in
        event agreedContextRecvSeppA(nonce, n32f_cid);
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicyRecvSeppA(n32f_cid, encp);
            out(n32c, (encp, modp));
            in(n32c, (ipx_b_id: bitstring, ipx_b_key: pubkey));
            out(n32c, (ipx_a_id, ipx_a_key));
            let master_key_a = deriveMasterKey(nonce) in
            event agreedMasterKeyRecvSeppA(n32f_cid, master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key).

let N32cSendKeyUpdateSeppA(sepp_a_privkey: privkey)=
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    new nonce: bitstring;
    let sig = sign(nonce, sepp_a_privkey) in
    out(n32c, (nonce, sig));
    let master_key_a = deriveMasterKey(nonce) in
    let session_key_a = deriveSessionKey(master_key_a) in
    insert localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    );
    event sendKeyUpdateSeppA(master_key_a).

let N32cRecvKeyUpdateSeppA(sepp_b_pubkey: pubkey)=
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    in(n32c, (nonce: bitstring, sig: bitstring));
    if checksign(sig, sepp_b_pubkey) then
    let master_key_a = deriveMasterKey(nonce) in
    let session_key_a = deriveSessionKey(master_key_a) in
    insert localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    );
    event recvKeyUpdateSeppA(master_key_a).


(* SEPP B N32-c Processes *)

let N32cSendHandshakeSeppB(sepp_b_privkey: privkey, cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_b_id: bitstring, ipx_b_key: pubkey)=
    new n32f_pid: bitstring;
    new nonce: bitstring;
    let sig = sign(nonce, sepp_b_privkey) in
    out(n32c, (cipher_suite, n32f_pid, nonce, sig));
    in(n32c, (cipher_suite_a: bitstring, n32f_pid_a: bitstring));
    if cipher_suite = cipher_suite_a then
        let n32f_cid = createContextId(n32f_pid, n32f_pid_a) in
        event agreedContextSendSeppB(nonce, n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicySendSeppB(n32f_cid, encp);
            out(n32c, (ipx_b_id, ipx_b_key));
            in(n32c, (ipx_a_id: bitstring, ipx_a_key: pubkey));
            let master_key_b = deriveMasterKey(nonce) in
            event agreedMasterKeySendSeppB(n32f_cid, master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key).

let N32cRecvHandshakeSeppB(sepp_a_pubkey: pubkey, cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_b_id: bitstring, ipx_b_key: pubkey)=
    new n32f_pid: bitstring;
    in(n32c, (cipher_suite_a: bitstring, n32f_pid_a: bitstring,
            nonce: bitstring, sig: bitstring));
    if checksign(sig, sepp_a_pubkey) && cipher_suite = cipher_suite_a then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_a, n32f_pid) in
        event agreedContextRecvSeppB(nonce, n32f_cid);
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicyRecvSeppB(n32f_cid, encp);
            out(n32c, (encp, modp));
            in(n32c, (ipx_a_id: bitstring, ipx_a_key: pubkey));
            out(n32c, (ipx_b_id, ipx_b_key));
            let master_key_b = deriveMasterKey(nonce) in
            event agreedMasterKeyRecvSeppB(n32f_cid, master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key).

let N32cSendKeyUpdateSeppB(sepp_b_privkey: privkey)=
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    new nonce: bitstring;
    let sig = sign(nonce, sepp_b_privkey) in
    out(n32c, (nonce, sig));
    let master_key_b = deriveMasterKey(nonce) in
    let session_key_b = deriveSessionKey(master_key_b) in
    insert localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    );
    event sendKeyUpdateSeppB(master_key_b).

let N32cRecvKeyUpdateSeppB(sepp_a_pubkey: pubkey)=
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    in(n32c, (nonce: bitstring, sig: bitstring));
    if checksign(sig, sepp_a_pubkey) then
    let master_key_b = deriveMasterKey(nonce) in
    let session_key_b = deriveSessionKey(master_key_b) in
    insert localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    );
    event recvKeyUpdateSeppB(master_key_b).


(* SEPP A N32-f Processes *)

let N32fSendSeppA(conf: bitstring, nonconf: bitstring)=
    new msg_id: bitstring;
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    let associated_data = combineAAD(nonconf, msg_id, ipx_a_id, n32f_context) in
    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        session_key_a,
        iv,
        conf,
        associated_data
    ) in
    out(n32f_ati, prins'(cipher_suite, iv, associated_data, payload, jwe_tag));
    event sendSeppA(n32f_context, msg_id, conf, nonconf).

let N32fRecvSeppA()=
    in(n32f_ati, prins_messsage: modprins);
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_messsage in
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id: bitstring,
        n32f_cid_b: bitstring
    ) = dataToIntegrityProtect in

    if n32f_cid_b = n32f_context then
        let conf = aeadDecrypt(
            session_key_a,
            iv,
            dataToIntegrityProtectAndCipher,
            dataToIntegrityProtect
        ) in
        event recvSeppA(n32f_context, msg_id, conf, nonconf);
        let jsonPatch(
            ipx_b_ops: bitstring,
            ipx_b_id': bitstring,
            jwe_tag_b: mac,
            ipx_b_jws: bitstring
        ) = ipx_b_mods in
        if checksignprins(ipx_b_jws, ipx_b_key) &&
            auth_ipx_id = ipx_b_id' &&
            ipx_b_ops = modp_b &&
            jwe_tag_b = jwe_tag then
            event recvAvalidIpxPatchB(n32f_context, jwe_tag_b, ipx_b_mods);

            let jsonPatch(
                ipx_a_ops: bitstring,
                ipx_a_id': bitstring,
                jwe_tag_a: mac,
                ipx_a_jws: bitstring
            ) = ipx_a_mods in
            if checksignmodprins(ipx_a_jws, ipx_a_key) &&
                ipx_a_id = ipx_a_id' &&
                ipx_a_ops = modp_a &&
                jwe_tag_a = jwe_tag then
                event recvAvalidIpxPatchA(n32f_context, jwe_tag_a, ipx_a_mods).


(* SEPP B N32-f Processes *)

let N32fSendSeppB(conf: bitstring, nonconf: bitstring)=
    new msg_id: bitstring;
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    let associated_data = combineAAD(nonconf, msg_id, ipx_b_id, n32f_context) in
    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        session_key_b,
        iv,
        conf,
        associated_data
    ) in
    out(n32f_bti, prins'(cipher_suite, iv, associated_data, payload, jwe_tag));
    event sendSeppB(n32f_context, msg_id, conf, nonconf).

let N32fRecvSeppB()=
    in(n32f_bti, prins_messsage: modprins);
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_a_mods: ipxmod,
        ipx_b_mods: ipxmod
    ) = prins_messsage in
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id: bitstring,
        n32f_cid_a: bitstring
    ) = dataToIntegrityProtect in
    if n32f_cid_a = n32f_context then
        let conf = aeadDecrypt(
            session_key_b,
            iv,
            dataToIntegrityProtectAndCipher,
            dataToIntegrityProtect
        ) in
        event recvSeppB(n32f_context, msg_id, conf, nonconf);
        let jsonPatch(
            ipx_a_ops: bitstring,
            ipx_a_id': bitstring,
            jwe_tag_a: mac,
            ipx_a_jws: bitstring
        ) = ipx_a_mods in
        if checksignprins(ipx_a_jws, ipx_a_key) &&
            auth_ipx_id = ipx_a_id' &&
            ipx_a_ops = modp_a &&
            jwe_tag_a = jwe_tag then
            event recvBvalidIpxPatchA(n32f_context, jwe_tag_a, ipx_a_mods);

            let jsonPatch(
                ipx_b_ops: bitstring,
                ipx_b_id': bitstring,
                jwe_tag_b: mac,
                ipx_b_jws: bitstring
            ) = ipx_b_mods in
            if checksignmodprins(ipx_b_jws, ipx_b_key) &&
                ipx_b_id' = ipx_b_id &&
                ipx_b_ops = modp_b &&
                jwe_tag_b = jwe_tag then
                event recvBvalidIpxPatchB(n32f_context, jwe_tag_b, ipx_b_mods).


(* IPX A Processes *)

let N32fSendIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_ati, (prins_message: prins));
    let prins'(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in
    let modified_message = prins''(
                jwe_headers,
                iv,
                dataToIntegrityProtect,
                dataToIntegrityProtectAndCipher,
                jwe_tag,
                modifications,
                empty
    ) in
    out(n32f_iti, modified_message);
    event ipxSendA(n32f_context, jwe_tag, modifications).

let N32fRecvIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        empty: ipxmod
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signmodprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    let combineAAD(
        nonconf: bitstring,
        msg_id : bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    out(n32f_ati, modified_message);
    event ipxRecvA(n32f_context, jwe_tag, modifications).


(* IPX B Processes *)

let N32fSendIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_bti, (prins_message: prins));
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        empty
    ) in
    out(n32f_iti, modified_message);
    event ipxSendB(n32f_context, jwe_tag, modifications).

let N32fRecvIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_a_mods: ipxmod,
        empty: ipxmod
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signmodprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    let combineAAD(
        nonconf: bitstring,
        msg_id : bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_a_mods,
        modifications
    ) in
    out(n32f_bti, modified_message);
    event ipxRecvB(n32f_context, jwe_tag, modifications).


(* Main Process *)

process
    new ciphersuites: bitstring;
    new encp: bitstring;
    new modp_a: bitstring;
    new modp_b: bitstring;
    new ipx_a_id: bitstring;
    new ipx_b_id: bitstring;

    new sepp_a_privkey: privkey;
    new sepp_b_privkey: privkey;
    let sepp_a_pubkey = pk(sepp_a_privkey) in out(n32f_ati, sepp_a_pubkey);
    let sepp_b_pubkey = pk(sepp_b_privkey) in out(n32f_bti, sepp_b_pubkey);

    new ipx_a_privkey: privkey;
    new ipx_b_privkey: privkey;
    let ipx_a_pubkey = pk(ipx_a_privkey) in out(n32f_ati, ipx_a_pubkey);
    let ipx_b_pubkey = pk(ipx_b_privkey) in out(n32f_bti, ipx_b_pubkey);

    ((N32cSendHandshakeSeppA(sepp_a_privkey, ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
    (!N32cRecvHandshakeSeppA(sepp_b_pubkey, ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
    (N32cSendHandshakeSeppB(sepp_b_privkey, ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
    (!N32cRecvHandshakeSeppB(sepp_a_pubkey, ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
    (N32fSendSeppA(msg_a_conf, msg_a_nonconf)) |
    (N32fSendSeppB(msg_b_conf, msg_b_nonconf)) |
    (!N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (!N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (!N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (!N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (!N32fRecvSeppA()) |
    (!N32fRecvSeppB()) |
    (phase 1; N32cSendKeyUpdateSeppA(sepp_a_privkey)) |
    (phase 1; N32cSendKeyUpdateSeppB(sepp_b_privkey)) |
    (phase 1; !N32cRecvKeyUpdateSeppA(sepp_b_pubkey)) |
    (phase 1; !N32cRecvKeyUpdateSeppB(sepp_a_pubkey)))