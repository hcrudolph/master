set traceDisplay = long.

(* Custom type definitions *)

type key.
type mac.
type privkey.
type pubkey.
type prins.
type modprins.
type aad.
type ipxmod.


(* Free names / channels *)

free n32f_ati: channel.             (* Channel between SEPP A and IPX A *)
free n32f_iti: channel.             (* Channel between IPX A and IPX B *)
free n32f_bti: channel.             (* Channel between IPX B and SEPP B *)
free n32c: channel [private].       (* Channel between SEPP A and SEPP B *)
const empty: ipxmod.

(* Tables - private by default *)

table localStorageSeppA(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP A modification policy *)
                        bitstring,  (* SEPP B modification policy *)
                        nat,        (* IPX A id *)
                        pubkey,     (* IPX A public key *)
                        nat,        (* IPX B id *)
                        pubkey).    (* IPX B public key *)

table localStorageSeppB(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP B modification policy *)
                        bitstring,  (* SEPP A modification policy *)
                        nat,        (* IPX B id *)
                        pubkey,     (* IPX B public key *)
                        nat,        (* IPX A id *)
                        pubkey).    (* IPX A public key *)


(* Custom Functions *)

fun deriveMasterKey(bitstring): key [private].
fun deriveSessionKey(key): key.
fun deriveIV(key): bitstring.

(* Custom Constructors *)

fun createContextId(bitstring, bitstring): bitstring.

fun combineAAD(bitstring,                   (* DataToIntegrityProtect *)
                bitstring,                  (* Msg Id *)
                nat,                        (* Authorized IPX *)
                bitstring):aad [data].      (* N32f Context Id *)

fun jsonPatch(bitstring,                    (* Operations *)
                nat,                        (* IPX Id *)
                bitstring,                  (* JWE Tag *)
                bitstring):ipxmod [data].   (* JWS Signature *)

fun appendPatch(prins,                      (* Original N32f Message *)
            ipxmod): prins [data].          (* IPX A Patch *)

fun prins'(bitstring,                       (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            bitstring): prins [data].       (* JWE Tag *)

fun prins''(bitstring,                      (* JWE Headers (Cipher Suites etc.) *)
            bitstring,                      (* Initialization Vector *)
            aad,                            (* DataToIntegrityProtect (AAD) *)
            bitstring,                      (* DataToIntegrityProtectAndCipher (Payload) *)
            bitstring,                      (* JWE Tag *)
            ipxmod,                         (* IPX A Patch *)
            ipxmod): modprins [data].       (* IPX B Patch *)

(* MAC *)
fun macf(bitstring, key): mac.
reduc forall m: bitstring, k: key; verify_mac(macf(m, k), m, k) = true.

(* Symmetric Encryption *)
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(* Signatures *)
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey; getmess(sign(m, k)) = m.
reduc forall m: bitstring, k: privkey; checksign(sign(m, k), pk(k)) = true.

fun signprins(prins, bitstring, nat, bitstring, privkey): bitstring.
fun signmodprins(modprins, bitstring, nat, bitstring, privkey): bitstring.
reduc forall p: modprins, ops: bitstring, id: nat, tag: bitstring, k: privkey;
    checksignmodprins(signmodprins(p, ops, id, tag, k), pk(k)) = true.

(* AEAD Encryption *)
fun encrypt(bitstring, key, bitstring): bitstring.
reduc forall msg: bitstring, k: key, iv: bitstring;
    decrypt(encrypt(msg, k, iv), k, iv) = msg.

reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadEncrypt(k, iv, payload, adata) = (
                                encrypt(payload, k, iv),
                                macf((iv, adata, encrypt(payload, k, iv)), k)
                                ).
reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadDecrypt(k, iv, (encrypt(payload, k, iv), macf((iv, adata, encrypt(payload, k, iv)), k)), adata) = payload.


(* Queries *)

event agreedContextSendSeppA(bitstring).
event agreedContextRecvSeppA(bitstring).
event agreedContextSendSeppB(bitstring).
event agreedContextRecvSeppB(bitstring).
event agreedEncPolicySendSeppA(bitstring, bitstring).
event agreedEncPolicyRecvSeppA(bitstring, bitstring).
event agreedEncPolicySendSeppB(bitstring, bitstring).
event agreedEncPolicyRecvSeppB(bitstring, bitstring).
event agreedMasterKeySendSeppA(bitstring, key).
event agreedMasterKeyRecvSeppA(bitstring, key).
event agreedMasterKeySendSeppB(bitstring, key).
event agreedMasterKeyRecvSeppB(bitstring, key).

event recvAvalidIpxPatchA(ipxmod).
event recvAvalidIpxPatchB(ipxmod).
event recvBvalidIpxPatchA(ipxmod).
event recvBvalidIpxPatchB(ipxmod).

event sendSeppA(bitstring, bitstring, bitstring).
event recvSeppA(bitstring, bitstring, bitstring).
event sendSeppB(bitstring, bitstring, bitstring).
event recvSeppB(bitstring, bitstring, bitstring).

event ipxModAin(ipxmod).
event ipxModAout(ipxmod).
event ipxModBin(ipxmod).
event ipxModBout(ipxmod).

(* encryption policies equivalent *)
query n32f_cid: bitstring, encp_a: bitstring, encp_b: bitstring;
    event(agreedEncPolicySendSeppA(n32f_cid, encp_a)) &&
    event(agreedEncPolicyRecvSeppB(n32f_cid, encp_b)) ==>
    encp_a = encp_b.

query n32f_cid: bitstring, encp_a: bitstring, encp_b: bitstring;
    event(agreedEncPolicySendSeppB(n32f_cid, encp_b)) &&
    event(agreedEncPolicyRecvSeppA(n32f_cid, encp_a)) ==>
    encp_b = encp_a.

(* master keys equivalent *)
query n32f_cid: bitstring, master_key_a: key, master_key_b: key;
    event(agreedMasterKeySendSeppA(n32f_cid, master_key_a)) &&
    event(agreedMasterKeyRecvSeppB(n32f_cid, master_key_b)) ==>
    master_key_a = master_key_b.

query n32f_cid: bitstring, master_key_a: key, master_key_b: key;
    event(agreedMasterKeySendSeppB(n32f_cid, master_key_b)) &&
    event(agreedMasterKeyRecvSeppA(n32f_cid, master_key_a)) ==>
    master_key_b = master_key_a.

(* IPX modifications valid *)
query mod_a: ipxmod, mod_b: ipxmod;
    inj-event(recvBvalidIpxPatchB(mod_b)) &&
    inj-event(recvBvalidIpxPatchA(mod_a)) ==>
    inj-event(ipxModBin(mod_b)) &&
    inj-event(ipxModAout(mod_a)).

query mod_a: ipxmod, mod_b: ipxmod;
    inj-event(recvAvalidIpxPatchB(mod_b)) &&
    inj-event(recvAvalidIpxPatchA(mod_a)) ==>
    inj-event(ipxModAin(mod_a)) &&
    inj-event(ipxModBout(mod_b)).

query n32f_cid: bitstring, conf_a: bitstring, conf_b: bitstring, nonconf_a: bitstring, nonconf_b: bitstring;
    inj-event(recvSeppA(n32f_cid, conf_a, nonconf_a)) ==>
    inj-event(sendSeppB(n32f_cid, conf_b, nonconf_b)) &&
    conf_a = conf_b &&
    nonconf_a = nonconf_b.

query n32f_cid: bitstring, conf_a: bitstring, conf_b: bitstring, nonconf_a: bitstring, nonconf_b: bitstring;
    inj-event(recvSeppB(n32f_cid, conf_b, nonconf_b)) ==>
    inj-event(sendSeppA(n32f_cid, conf_a, nonconf_a)) &&
    conf_a = conf_b &&
    nonconf_a = nonconf_b.

free master_key_a, master_key_b, session_key_a, session_key_b: key [private].

query attacker(master_key_a);
      attacker(master_key_b).

query attacker(session_key_a);
      attacker(session_key_b).

noninterf master_key_a.
noninterf master_key_b.
weaksecret master_key_a.
weaksecret master_key_b.


(* SEPP A N32-c Processes *)

let N32cSendSeppA(cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_a_id: nat, ipxkey: pubkey)=
    (* create random N32-f precontext id *)
    new n32f_pid: bitstring;
    out(n32c, (cipher_suite, n32f_pid));
    in(n32c, (cs_b: bitstring, n32f_pid_b: bitstring));
    if cipher_suite = cs_b then
        (* create N32-f context from precontext ids *)
        let n32f_cid = createContextId(n32f_pid, n32f_pid_b) in
        event agreedContextSendSeppA(n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicySendSeppA(n32f_cid, encp);
            out(n32c, (ipx_a_id, ipxkey));
            in(n32c, (ipx_b_id: nat, ipx_b_key: pubkey));
            let master_key_a = deriveMasterKey(n32f_cid) in
            event agreedMasterKeySendSeppA(n32f_cid, master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp, modp_b, ipx_a_id, ipxkey, ipx_b_id, ipx_b_key).

let N32cRecvSeppA(cipher_suite: bitstring, encp: bitstring, modp_a: bitstring, ipx_a_id: nat, ipxkey: pubkey)=
    (* create random N32-f precontext id *)
    new n32f_pid: bitstring;
    in(n32c, (cs_b: bitstring, n32f_pid_b: bitstring));
    if cipher_suite = cs_b then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_b, n32f_pid) in
        (* Create N32-f context from precontext ids *)
        event agreedContextRecvSeppA(n32f_cid);
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicyRecvSeppA(n32f_cid, encp);
            out(n32c, (encp, modp_a));
            in(n32c, (ipx_b_id: nat, ipx_b_key: pubkey));
            out(n32c, (ipx_a_id, ipxkey));
            let master_key_a = deriveMasterKey(n32f_cid) in
            event agreedMasterKeyRecvSeppA(n32f_cid, master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp_a, modp_b, ipx_a_id, ipxkey, ipx_b_id, ipx_b_key).


(* SEPP B N32-c Processes *)

let N32cSendSeppB(cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_b_id: nat, ipxkey: pubkey)=
    new n32f_pid: bitstring;
    out(n32c, (cipher_suite, n32f_pid));
    in(n32c, (cs_a: bitstring, n32f_pid_a: bitstring));
    if cipher_suite = cs_a then
        let n32f_cid = createContextId(n32f_pid, n32f_pid_a) in
        event agreedContextSendSeppB(n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicySendSeppB(n32f_cid, encp);
            out(n32c, (ipx_b_id, ipxkey));
            in(n32c, (ipx_a_id: nat, ipxkey_a: pubkey));
            let master_key_b = deriveMasterKey(n32f_cid) in
            event agreedMasterKeySendSeppB(n32f_cid, master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipx_b_id, ipxkey, ipx_a_id, ipxkey_a).

let N32cRecvSeppB(cipher_suite: bitstring, encp: bitstring, modp: bitstring, ipx_b_id: nat, ipxkey: pubkey)=
    new n32f_pid: bitstring;
    in(n32c, (cs_a: bitstring, n32f_pid_a: bitstring));
    if cipher_suite = cs_a then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_a, n32f_pid) in
        event agreedContextRecvSeppB(n32f_cid);
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicyRecvSeppB(n32f_cid, encp);
            out(n32c, (encp, modp));
            in(n32c, (ipx_a_id: nat, ipxkey_a: pubkey));
            out(n32c, (ipx_b_id, ipxkey));
            let master_key_b = deriveMasterKey(n32f_cid) in
            event agreedMasterKeyRecvSeppB(n32f_cid, master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipx_b_id, ipxkey, ipx_a_id, ipxkey_a).


(* SEPP A N32-f Processes *)

let N32fSendSeppA(conf: bitstring, nonconf: bitstring)=
    new message_id: bitstring;
    get localStorageSeppA(n32f_context, session_key, iv, cipher_suite, encp,
                            modp_a, modp_b, ipx_a_id, ipxkey_a, ipx_b_id, ipx_b_key) in
    let associated_data = combineAAD(nonconf, message_id, ipx_a_id, n32f_context) in
    let (payload: bitstring, jwe_tag: bitstring) = aeadEncrypt(
            session_key,
            iv,
            conf,
            associated_data
    ) in
    out(n32f_ati, prins'(cipher_suite, iv, associated_data, payload, jwe_tag));
    event sendSeppA(n32f_context, conf, nonconf).

let N32fRecvSeppA()=
    in(n32f_bti, prins_messsage: modprins);
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipx_mods_b: ipxmod,
        ipx_mods_a: ipxmod
    ) = prins_messsage in
    get localStorageSeppB(n32f_context, session_key, iv, cipher_suite, encp,
                            modp_a, modp_b, ipx_a_id, ipxkey_a, ipx_b_id, ipx_b_key) in

    let conf = aeadDecrypt(
        session_key,
        iv,
        dataToIntegrityProtectAndCipher,
        dataToIntegrityProtect
    ) in

    let combineAAD(
        nonconf: bitstring,
        message_id: bitstring,
        auth_ipx_id: nat,
        n32f_cid_b: bitstring
    ) = dataToIntegrityProtect in

    if n32f_cid_b = n32f_context then
        event recvSeppA(n32f_context, conf, nonconf);
        let jsonPatch(
            ops_b: bitstring,
            ipx_b_id': nat,
            jwe_tag_b: bitstring,
            jws_signature_b: bitstring
        ) = ipx_mods_b in
        if checksignmodprins(jws_signature_b, ipx_b_key) &&
            auth_ipx_id = ipx_b_id' &&
            jwe_tag_b = jwe_tag then
            event recvAvalidIpxPatchB(ipx_mods_b);

        let jsonPatch(
            ops_a: bitstring,
            ipx_a_id': nat,
            jwe_tag_a: bitstring,
            jws_signature_a: bitstring
        ) = ipx_mods_a in
        if checksignmodprins(jws_signature_a, ipxkey_a) &&
            ipx_a_id = ipx_a_id' &&
            jwe_tag_a = jwe_tag then
            event recvAvalidIpxPatchA(ipx_mods_a).


(* SEPP B N32-f Processes *)

let N32fSendSeppB(conf: bitstring, nonconf: bitstring)=
    new message_id: bitstring;
    get localStorageSeppA(n32f_context, session_key, iv, cipher_suite, encp,
                            modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipxkey_a) in
    let associated_data = combineAAD(nonconf, message_id, ipx_b_id, n32f_context) in
    let (payload: bitstring, jwe_tag: bitstring) = aeadEncrypt(
            session_key,
            iv,
            conf,
            associated_data
    ) in
    out(n32f_bti, prins'(cipher_suite, iv, associated_data, payload, jwe_tag));
    event sendSeppB(n32f_context, conf, nonconf).

let N32fRecvSeppB()=
    in(n32f_bti, prins_messsage: modprins);
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipx_mods_a: ipxmod,
        ipx_mods_b: ipxmod
    ) = prins_messsage in
    get localStorageSeppB(n32f_context, session_key, iv, cipher_suite, encp,
                            modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipxkey_a) in
    let conf = aeadDecrypt(
        session_key,
        iv,
        dataToIntegrityProtectAndCipher,
        dataToIntegrityProtect
    ) in

    let combineAAD(
        nonconf: bitstring,
        message_id: bitstring,
        auth_ipx_id: nat,
        n32f_cid_a: bitstring
    ) = dataToIntegrityProtect in
    if n32f_cid_a = n32f_context then
        event recvSeppB(n32f_context, conf, nonconf);
        let jsonPatch(
            ops_a: bitstring,
            ipx_a_id': nat,
            jwe_tag_a: bitstring,
            jws_signature_a: bitstring
        ) = ipx_mods_a in
        if checksignmodprins(jws_signature_a, ipxkey_a) &&
            auth_ipx_id = ipx_a_id' &&
            jwe_tag_a = jwe_tag then
            event recvBvalidIpxPatchA(ipx_mods_a);

        let jsonPatch(
            ops_b: bitstring,
            ipx_b_id': nat,
            jwe_tag_b: bitstring,
            jws_signature_b: bitstring
        ) = ipx_mods_b in
        if checksignmodprins(jws_signature_b, ipx_b_key) &&
            ipx_b_id' = ipx_b_id &&
            jwe_tag_b = jwe_tag then
            event recvBvalidIpxPatchB(ipx_mods_b).


(* IPX A Process *)

let N32fSendIpxA(id: nat, privkey: privkey, ops: bitstring)=
    in(n32f_ati, (prins_message: prins));
    let prins'(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    event ipxModAout(modifications);
    let modified_message = prins''(
                jwe_headers,
                iv,
                dataToIntegrityProtect,
                dataToIntegrityProtectAndCipher,
                jwe_tag,
                modifications,
                empty
    ) in
    out(n32f_iti, modified_message).

let N32fRecvIpxA(id: nat, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipxModificationsB: ipxmod,
        empty: ipxmod
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signmodprins(prins_message, ops, id, jwe_tag, privkey)) in
    event ipxModAin(modifications);
    let modified_message = prins''(jwe_headers,
                                    iv,
                                    dataToIntegrityProtect,
                                    dataToIntegrityProtectAndCipher,
                                    jwe_tag,
                                    ipxModificationsB,
                                    modifications
    ) in
    out(n32f_ati, modified_message).

(* IPX B Process *)

let N32fSendIpxB(id: nat, privkey: privkey, ops: bitstring)=
    in(n32f_bti, (prins_message: prins));
    let prins'(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    event ipxModBout(modifications);
    let modified_message = prins''(
                jwe_headers,
                iv,
                dataToIntegrityProtect,
                dataToIntegrityProtectAndCipher,
                jwe_tag,
                modifications,
                empty
    ) in
    out(n32f_iti, modified_message).

let N32fRecvIpxB(id: nat, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));
    let prins''(jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: bitstring,
        ipxModificationsA: ipxmod,
        empty: ipxmod
    ) = prins_message in
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signmodprins(prins_message, ops, id, jwe_tag, privkey)
    ) in
    event ipxModBin(modifications);
    let modified_message = prins''(jwe_headers,
                                    iv,
                                    dataToIntegrityProtect,
                                    dataToIntegrityProtectAndCipher,
                                    jwe_tag,
                                    ipxModificationsA,
                                    modifications
    ) in
    out(n32f_ati, modified_message).


(* Main Process *)

process
    new ciphersuites_a: bitstring; new ciphersuite_b: bitstring;
    new encp_a: bitstring; new encp_b: bitstring;
    new modp_a: bitstring; new modp_b: bitstring;
    new message_a_conf: bitstring; new message_a_nonconf: bitstring;
    new message_b_conf: bitstring; new message_b_nonconf: bitstring;
    let ipx_a_id = 0 in
    let ipx_b_id = 1 in
    (* Create key pairs & publish public keys *)
    new sepp_a_privkey: privkey; new sepp_b_privkey: privkey;
    let sepp_a_pubkey = pk(sepp_a_privkey) in out(n32f_ati, sepp_a_pubkey);
    let sepp_b_pubkey = pk(sepp_b_privkey) in out(n32f_ati, sepp_b_pubkey);

    new ipx_a_privkey: privkey; new ipx_b_privkey: privkey;
    let ipx_a_pubkey = pk(ipx_a_privkey) in out(n32f_ati, ipx_a_pubkey);
    let ipx_b_pubkey = pk(ipx_b_privkey) in out(n32f_ati, ipx_b_pubkey);

    (N32cSendSeppA(ciphersuites_a, encp_a, modp_a, ipx_a_id, ipx_a_pubkey)) |
    (N32cSendSeppB(ciphersuite_b, encp_b, modp_b, ipx_b_id, ipx_b_pubkey)) |
    (N32cRecvSeppA(ciphersuites_a, encp_a, modp_a, ipx_a_id, ipx_a_pubkey)) |
    (N32cRecvSeppB(ciphersuite_b, encp_b, modp_b, ipx_b_id, ipx_b_pubkey)) |
    (phase 1; !N32fSendSeppA(message_a_conf, message_a_nonconf)) |
    (!N32fSendSeppB(message_b_conf, message_b_nonconf)) |
    (!N32fRecvSeppA()) |
    (!N32fRecvSeppB()) |
    (!N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (!N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (!N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (!N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b))