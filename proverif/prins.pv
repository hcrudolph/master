set privateCommOnPublicFreeNames = false.
set preciseActions = false.

(* custom types *)

type key.                           (* symmetric key *)
type mac.                           (* message authentication code *)
type http.                          (* http message *)
type privkey.                       (* asymmetric privat key *)
type pubkey.                        (* asymmetric public key *)
type prins.                         (* prins message *)
type modprins.                      (* modified prins message w/ patches *)
type aad.                           (* additional authenticated data *)
type ipxmod.                        (* json patch / ipx modifications *)

(* channels *)

free plmn_a: channel [private].     (* PLMN A internal channel *)
free plmn_b: channel [private].     (* PLMN B internal channel *)
free n32f_a: channel.               (* Channel between SEPP A and IPX A *)
free n32f_i: channel.               (* Channel between IPX A and IPX B *)
free n32f_b: channel.               (* Channel between IPX B and SEPP B *)
free n32c: channel [private].       (* Channel between SEPP A and SEPP B *)
free err_a: channel [private].      (* Internal error signalling Sepp A *)
free err_b: channel [private].      (* Internal error signalling Sepp B *)

(* global constants *)

const EMPTY: ipxmod.                (* the empty ipx patch *)
const SUCC: bitstring.              (* success flag *)
const FAIL: bitstring.              (* failure flag *)
const SEND: bitstring.              (* sending flag *)
const RECV: bitstring.              (* receiving flag *)
const REQ: bitstring.               (* HTTP Request *)
const RES: bitstring.               (* HTTP Response *)

(* tables *)

table storeSeppA(
    bitstring,                      (* SEPP B PLMN ID *)
    bitstring,                      (* SEPP B Address *)
    bitstring,                      (* N32-f Context ID *)
    nat,                            (* N32-f Message Counter *)
    key,                            (* parallel request key *)
    key,                            (* parallel response key *)
    key,                            (* reverse request key *)
    key,                            (* reverse response key *)
    bitstring,                      (* parallel request IV *)
    bitstring,                      (* parallel response IV *)
    bitstring,                      (* reverse request IV *)
    bitstring,                      (* reverse response IV *)
    bitstring,                      (* JWE Ciphersuite *)
    bitstring,                      (* Data-type encryption policy *)
    bitstring,                      (* SEPP A modification policy *)
    bitstring,                      (* SEPP B modification policy *)
    bitstring,                      (* IPX A id *)
    pubkey,                         (* IPX A public key *)
    bitstring,                      (* IPX B id *)
    pubkey).                        (* IPX B public key *)

table storeSeppB(
    bitstring,                      (* SEPP A PLMN ID *)
    bitstring,                      (* SEPP A Address *)
    bitstring,                      (* N32-f Context ID *)
    nat,                            (* N32-f Message Counter *)
    key,                            (* parallel request key *)
    key,                            (* parallel response key *)
    key,                            (* reverse request key *)
    key,                            (* reverse response key *)
    bitstring,                      (* parallel request IV *)
    bitstring,                      (* parallel response IV *)
    bitstring,                      (* reverse request IV *)
    bitstring,                      (* reverse response IV *)
    bitstring,                      (* JWE Ciphersuite *)
    bitstring,                      (* Data-type encryption policy *)
    bitstring,                      (* SEPP B modification policy *)
    bitstring,                      (* SEPP A modification policy *)
    bitstring,                      (* IPX B id *)
    pubkey,                         (* IPX B public key *)
    bitstring,                      (* IPX A id *)
    pubkey).                        (* IPX A public key *)

(* custom data constructors *)

fun createHttp(bitstring,           (* Source address *)
        bitstring,                  (* Destination address *)
        bitstring,                  (* Message type REQ/RES *)
        bitstring): http [data].    (* content *)

fun combineAAD(bitstring,           (* HTTP Soure Address *)
        bitstring,                  (* HTTP Dest Address *)
        bitstring,                  (* HTTP Msg Type *)
        bitstring,                  (* HTTP Body *)
        nat,                        (* Message ID *)
        bitstring,                  (* Authorized IPX *)
        bitstring): aad [data].     (* N32f Context Id *)

fun jsonPatch(bitstring,            (* Operations *)
        bitstring,                  (* IPX Id *)
        mac,                        (* JWE Tag *)
        bitstring): ipxmod [data].  (* JWS Signature *)

fun prins'(bitstring,               (* JWE Headers *)
        bitstring,                  (* Initialization Vector *)
        aad,                        (* DataToIntegrityProtect *)
        bitstring,                  (* DataToIntegrityProtectAndCipher *)
        mac): prins [data].         (* JWE Tag *)

fun prins''(bitstring,              (* JWE Headers *)
        bitstring,                  (* Initialization Vector *)
        aad,                        (* DataToIntegrityProtect *)
        bitstring,                  (* DataToIntegrityProtectAndCipher *)
        mac,                        (* JWE Tag *)
        ipxmod,                     (* IPX A Patch *)
        ipxmod): modprins [data].   (* IPX B Patch *)

(* custom functions *)

fun deriveContextId(bitstring, bitstring): bitstring.
fun deriveMasterKey(bitstring, nat): key [private].
fun deriveSessionKey(bitstring, bitstring, key): key.
fun deriveIV(bitstring, bitstring, key): bitstring.
fun deriveNonce(bitstring, nat): bitstring.
fun applyPatches(bitstring, bitstring, bitstring): bitstring.

(* mac *)
fun macf(bitstring, key): mac.

(* data-type encryption policy application *)
fun getConf(bitstring, bitstring): bitstring.
fun getNonconf(bitstring, bitstring): bitstring.
fun policyValidation(bitstring, bitstring): bool
    reduc forall m: bitstring, p: bitstring;
        policyValidation(getNonconf(m, p), p) = true
    otherwise forall m: bitstring, p: bitstring, p': bitstring;
        policyValidation(getNonconf(m, p), p') = false.

(* signatures *)
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey;
    checkSign(sign(m, k), pk(k)) = m.
reduc forall m: bitstring, k: privkey;
    getMess(sign(m, k)) = m.

fun signPrins(prins, bitstring, bitstring, mac, privkey): bitstring.
reduc forall p: prins, ops: bitstring, id: bitstring, tag: mac, k: privkey;
    validPrinsSign(signPrins(p, ops, id, tag, k), pk(k)) = true.
fun signPrinsMod(modprins, bitstring, bitstring, mac, privkey): bitstring.
reduc forall p: modprins, ops: bitstring, id: bitstring, tag: mac, k: privkey;
    validPrinsModSign(signPrinsMod(p, ops, id, tag, k), pk(k)) = true.

(* aead encryption *)
fun encrypt(bitstring, key, bitstring): bitstring.
reduc forall msg: bitstring, k: key, iv: bitstring;
    decrypt(encrypt(msg, k, iv), k, iv) = msg.

reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadEncrypt(k, iv, payload, adata) = (
        encrypt(payload, k, iv),
        macf((iv, adata, encrypt(payload, k, iv)), k)
    ).
reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadDecrypt(
        k,
        iv,
        (
            encrypt(payload, k, iv),
            macf((iv, adata, encrypt(payload, k, iv)), k)
        ),
        adata
    ) = payload.


(* event definitions *)

event sentN32fContext(bitstring, bitstring, bitstring, bitstring).
event recvN32fContext(bitstring, bitstring, bitstring, bitstring).

event agreedEncPolicySend(bitstring, bitstring, bitstring).
event agreedEncPolicyRecv(bitstring, bitstring, bitstring).

event sentMasterKey(bitstring, bitstring, key).
event recvMasterKey(bitstring, bitstring, key).

event sentHttpMsgNfA(bitstring, bitstring).
event recvHttpMsgNfA(bitstring, bitstring).
event sentHttpMsgNfB(bitstring, bitstring).
event recvHttpMsgNfB(bitstring, bitstring).

event sentHttpMsgSeppA(bitstring, bitstring).
event recvHttpMsgSeppA(bitstring, bitstring).
event sentHttpMsgSeppB(bitstring, bitstring).
event recvHttpMsgSeppB(bitstring, bitstring).

event sentN32fMsgSeppA(bitstring, nat, bitstring, bitstring).
event recvN32fMsgSeppA(bitstring, nat, bitstring, bitstring).
event sentN32fMsgSeppB(bitstring, nat, bitstring, bitstring).
event recvN32fMsgSeppB(bitstring, nat, bitstring, bitstring).

event recvValidIpxPatchSeppA(bitstring, bitstring, mac, ipxmod).
event recvValidIpxPatchSeppB(bitstring, bitstring, mac, ipxmod).
event recvInvalIpxPatchSeppA(bitstring, bitstring, mac, ipxmod).
event recvInvalIpxPatchSeppB(bitstring, bitstring, mac, ipxmod).

event errorSignalingSend(bitstring, bitstring, nat, bitstring).
event errorSignalingRecv(bitstring, bitstring, nat, bitstring).

event ipxRecvA(bitstring, mac, ipxmod).
event ipxSendA(bitstring, mac, ipxmod).
event ipxRecvB(bitstring, mac, ipxmod).
event ipxSendB(bitstring, mac, ipxmod).
event ipxRecvR1(bitstring, mac, ipxmod).
event ipxSendR1(bitstring, mac, ipxmod).
event ipxRecvR2(bitstring, mac, ipxmod).
event ipxSendR2(bitstring, mac, ipxmod).
event ipxRecvR3(bitstring, mac, ipxmod).


(* secrecy queries *)

free master_key_a, master_key_b,
    par_req_key_a, par_res_key_a, rev_req_key_a, rev_res_key_a,
    par_req_key_b, par_res_key_b, rev_req_key_b, rev_res_key_b: key [private].

(* master & session key confidentiality *)
query attacker(master_key_a);
      attacker(master_key_b).
query attacker(par_req_key_a);
      attacker(par_res_key_a);
      attacker(rev_req_key_a);
      attacker(rev_res_key_a);
      attacker(par_req_key_b);
      attacker(par_res_key_b);
      attacker(rev_req_key_b);
      attacker(rev_res_key_b).

free conf: bitstring [private].

(* sec property 7: message confidentiality *)
query attacker(conf).


(* Debugging queries *)
query msg: bitstring;
    event(sentHttpMsgNfA(REQ, msg));
    event(sentHttpMsgNfA(RES, msg));
    event(sentHttpMsgNfB(REQ, msg));
    event(sentHttpMsgNfB(RES, msg));
    event(recvHttpMsgNfA(REQ, msg));
    event(recvHttpMsgNfA(RES, msg));
    event(recvHttpMsgNfB(REQ, msg));
    event(recvHttpMsgNfB(RES, msg)).

query msg: bitstring;
    event(sentHttpMsgSeppA(REQ, msg));
    event(sentHttpMsgSeppA(RES, msg));
    event(sentHttpMsgSeppB(REQ, msg));
    event(sentHttpMsgSeppB(RES, msg));
    event(recvHttpMsgSeppA(REQ, msg));
    event(recvHttpMsgSeppA(RES, msg));
    event(recvHttpMsgSeppB(REQ, msg));
    event(recvHttpMsgSeppB(RES, msg)).

query msg: bitstring, n32f_context: bitstring, msg_id: nat,
    encp: bitstring, http_method: bitstring;
    event(sentN32fMsgSeppA(n32f_context, msg_id,
        getConf(msg, encp), getNonconf(msg, encp))) ==>
    event(sentHttpMsgNfA(http_method, msg));

    event(sentN32fMsgSeppB(n32f_context, msg_id,
        getConf(msg, encp), getNonconf(msg, encp))) ==>
    event(sentHttpMsgNfB(http_method, msg)).

query n32f_context: bitstring, jwe_tag: mac, ipx_mods: ipxmod;
    event(ipxSendR1(n32f_context, jwe_tag, ipx_mods));
    event(ipxRecvR1(n32f_context, jwe_tag, ipx_mods));
    event(ipxSendR2(n32f_context, jwe_tag, ipx_mods));
    event(ipxRecvR2(n32f_context, jwe_tag, ipx_mods));
    event(ipxRecvR3(n32f_context, jwe_tag, ipx_mods)).

query ipx_id: bitstring, n32f_context: bitstring, jwe_tag: mac, ipx_mods: ipxmod;
    event(recvInvalIpxPatchSeppA(ipx_id, n32f_context, jwe_tag, ipx_mods));
    event(recvValidIpxPatchSeppA(ipx_id, n32f_context, jwe_tag, ipx_mods));
    event(recvInvalIpxPatchSeppB(ipx_id, n32f_context, jwe_tag, ipx_mods));
    event(recvValidIpxPatchSeppB(ipx_id, n32f_context, jwe_tag, ipx_mods)).


(* sec property 3: N32-f Context IDs equivalent *)
query sepp_a_addr: bitstring, sepp_b_addr: bitstring,
    n32f_a_pid: bitstring, n32f_b_pid: bitstring,
    n32f_context_a: bitstring, n32f_context_b: bitstring;

    event(recvN32fContext(
        sepp_b_addr, n32f_a_pid, n32f_b_pid, n32f_context_b
    )) &&
    event(sentN32fContext(
        sepp_a_addr, n32f_a_pid, n32f_b_pid, n32f_context_a
    )) ==>
    (n32f_context_a = n32f_context_b);

    event(recvN32fContext(
        sepp_a_addr, n32f_a_pid, n32f_b_pid, n32f_context_a
    )) &&
    event(sentN32fContext(
        sepp_b_addr, n32f_a_pid, n32f_b_pid, n32f_context_b
    )) ==>
    (n32f_context_a = n32f_context_b).

(* sec property 4: master keys equivalent *)
query sepp_a_addr: bitstring, sepp_b_addr: bitstring, n32f_cid: bitstring,
    mkey_a: key, mkey_b: key;
    event(recvMasterKey(sepp_b_addr, n32f_cid, mkey_a)) &&
    event(sentMasterKey(sepp_a_addr, n32f_cid, mkey_b)) ==>
    mkey_a = mkey_b;

    event(recvMasterKey(sepp_a_addr, n32f_cid, mkey_a)) &&
    event(sentMasterKey(sepp_b_addr, n32f_cid, mkey_b)) ==>
    mkey_b = mkey_a.

(* sec property 6/7/11: integrity protection / authentication *)
query msg_id: nat, n32f_context: bitstring,
    msg_conf: bitstring, msg_nonconf: bitstring;
    event(sentN32fMsgSeppB(n32f_context, msg_id, msg_conf, msg_nonconf)) &&
    event(recvN32fMsgSeppA(n32f_context, msg_id, msg_conf, msg_nonconf));

    event(recvN32fMsgSeppA(n32f_context, msg_id, msg_conf, msg_nonconf)) ==>
    inj-event(sentN32fMsgSeppB(n32f_context, msg_id, msg_conf, msg_nonconf)).

query msg_id: nat, n32f_context: bitstring,
    msg_conf: bitstring, msg_nonconf: bitstring;
    event(sentN32fMsgSeppA(n32f_context, msg_id, msg_conf, msg_nonconf)) &&
    event(recvN32fMsgSeppB(n32f_context, msg_id, msg_conf, msg_nonconf));

    event(recvN32fMsgSeppB(n32f_context, msg_id, msg_conf, msg_nonconf)) ==>
    inj-event(sentN32fMsgSeppA(n32f_context, msg_id, msg_conf, msg_nonconf)).

(* sec property 9: json patch authentication/integrity protection *)
query n32f_context: bitstring, ipx_a_id: bitstring, ipx_b_id: bitstring,
    jwe_tag: mac, ipx_a_mods: ipxmod, ipx_b_mods: ipxmod;

    event(
        recvValidIpxPatchSeppA(
            ipx_a_id, n32f_context, jwe_tag, ipx_a_mods
        )
    ) ==> (
    inj-event(
        recvValidIpxPatchSeppA(
            ipx_b_id, n32f_context, jwe_tag, ipx_b_mods
        )
    ) ==> (
    inj-event(
        ipxRecvA(n32f_context, jwe_tag, ipx_a_mods)
    ) ==>
        inj-event(ipxSendB(n32f_context, jwe_tag, ipx_b_mods))
    )).

query n32f_context: bitstring, ipx_a_id: bitstring, ipx_b_id: bitstring,
    jwe_tag: mac, ipx_a_mods: ipxmod, ipx_b_mods: ipxmod;

    event(
        recvValidIpxPatchSeppB(
            ipx_b_id, n32f_context, jwe_tag, ipx_b_mods
        )
    ) ==> (
    inj-event(
        recvValidIpxPatchSeppB(
            ipx_a_id, n32f_context, jwe_tag, ipx_a_mods
        )
    ) ==> (
    inj-event(
        ipxRecvB(n32f_context, jwe_tag, ipx_b_mods)
    ) ==>
        inj-event(ipxSendA(n32f_context, jwe_tag, ipx_a_mods))
    )).

(* sec property 10: rejecting replayed json patches *)
query ipx_a_id: bitstring, n32f_context: bitstring,
    jwe_tag: mac, ipx_mods: ipxmod;

    event(recvValidIpxPatchSeppA(
        ipx_a_id, n32f_context, jwe_tag, ipx_mods)) &&
    event(ipxRecvR3(n32f_context, jwe_tag, ipx_mods)).

(* sec property 12: rejecting unknown ipx providers *)
query ipx_a_id: bitstring, n32f_context: bitstring,
    jwe_tag: mac, ipx_a_mods: ipxmod;

    event(recvValidIpxPatchSeppA(
        ipx_a_id, n32f_context, jwe_tag, ipx_a_mods)) &&
    event(ipxRecvR2(n32f_context, jwe_tag, ipx_a_mods)).

query ipx_a_id: bitstring, n32f_context: bitstring,
    jwe_tag: mac, ipx_a_mods: ipxmod;

    event(recvValidIpxPatchSeppB(
        ipx_a_id, n32f_context, jwe_tag, ipx_a_mods)) &&
    event(ipxSendR2(n32f_context, jwe_tag, ipx_a_mods)).

(* sec property 13: rejecting unknown message modifications *)
query ipx_a_id: bitstring, n32f_context: bitstring,
    jwe_tag: mac, ipx_mods: ipxmod;

    event(recvValidIpxPatchSeppB(
        ipx_a_id, n32f_context, jwe_tag, ipx_mods)) &&
    event(ipxSendR1(n32f_context, jwe_tag, ipx_mods)).

(* sec property 8: removing previous message modifications *)
query ipx_b_id: bitstring, n32f_context: bitstring,
    jwe_tag: mac, ipx_a_mods: ipxmod, ipx_b_mods: ipxmod;

    event(recvValidIpxPatchSeppA(
        ipx_b_id, n32f_context, jwe_tag, ipx_b_mods)) &&
    event(ipxRecvR1(n32f_context, jwe_tag, ipx_a_mods)).


(* NF A Processes *)

let NfARequest(nf_a_addr: bitstring, nf_b_addr: bitstring)=
    new msg_body: bitstring;
    let http_message =
        createHttp(nf_a_addr, nf_b_addr, REQ, msg_body) in
    out(plmn_a, http_message);
    event sentHttpMsgNfA(REQ, msg_body).

let NfAResponse(nf_a_addr: bitstring, nf_b_addr: bitstring)=
    in(plmn_a, msg: http);
    let createHttp(nf_b_addr: bitstring,
        nf_a_addr': bitstring,
        msg_type: bitstring,
        msg_body: bitstring) = msg in
    if nf_a_addr' = nf_a_addr then
    (
        if msg_type = REQ then
        (
            event recvHttpMsgNfA(REQ, msg_body);
            out(plmn_a, createHttp(nf_a_addr, nf_b_addr, RES, msg_body));
            event sentHttpMsgNfA(RES, msg_body)
        )
        else
        (
            event recvHttpMsgNfA(RES, msg_body)
        )
    ).

(* SEPP A N32-c Processes *)

let N32cSendHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    in(n32c, (
        sepp_a_addr': bitstring, ciphers_b: bitstring, n32f_pid_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr then
    let n32f_cid = deriveContextId(n32f_pid, n32f_pid_b) in
    event sentN32fContext(sepp_a_addr, n32f_pid, n32f_pid_b, n32f_cid);

    (* verify matching encryption policies *)
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));
    in(n32c, (sepp_a_addr': bitstring, n32f_cid': bitstring,
        encp_b: bitstring, modp_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr &&
        n32f_cid' = n32f_cid &&
        encp_b = encp_a then
    event agreedEncPolicySend(sepp_a_addr, n32f_cid, encp_a);

    (* exchange ipx information *)
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));
    in(n32c, (
        sepp_a_addr': bitstring, n32f_cid': bitstring,
        ipx_b_id: bitstring, ipx_b_key: pubkey
    ));

    (* key derivation *)
    if sepp_a_addr' = sepp_a_addr && n32f_cid' = n32f_cid then
    let msg_cnt_a = 0 in
    let master_key_a = deriveMasterKey(n32f_cid, msg_cnt_a) in
    event sentMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_req_key_a = deriveSessionKey(SEND, REQ, master_key_a) in
    let rev_req_key_a = deriveSessionKey(RECV, REQ, master_key_a) in
    let par_res_key_a = deriveSessionKey(SEND, RES, master_key_a) in
    let rev_res_key_a = deriveSessionKey(RECV, RES, master_key_a) in
    let par_req_iv_a = deriveIV(SEND, REQ, master_key_a) in
    let rev_req_iv_a = deriveIV(RECV, REQ, master_key_a) in
    let par_res_iv_a = deriveIV(SEND, RES, master_key_a) in
    let rev_res_iv_a = deriveIV(RECV, RES, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).

let N32cRecvHandshakeSeppA(sepp_a_plmn: bitstring, sepp_a_addr: bitstring,
    sepp_b_plmn: bitstring, sepp_b_addr: bitstring, ciphers_a: bitstring,
    encp_a: bitstring, modp_a: bitstring, ipx_a_id: bitstring,
    ipx_a_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    in(n32c, (
        sepp_a_addr': bitstring, ciphers_b: bitstring,
        n32f_pid_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr && ciphers_a = ciphers_b then
    out(n32c, (sepp_b_addr, ciphers_a, n32f_pid));
    let n32f_cid = deriveContextId(n32f_pid_b, n32f_pid) in
    event recvN32fContext(sepp_a_addr, n32f_pid_b, n32f_pid, n32f_cid);

    (* verify matching encryption policies *)
    in(n32c, (sepp_a_addr': bitstring, n32f_cid': bitstring,
        encp_b: bitstring, modp_b: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr &&
        n32f_cid' = n32f_cid &&
        encp_b = encp_a then
    out(n32c, (sepp_b_addr, n32f_cid, encp_a, modp_a));
    event agreedEncPolicyRecv(sepp_a_addr, n32f_cid, encp_a);

    (* exchange ipx information *)
    in(n32c, (
        sepp_a_addr': bitstring, n32f_cid': bitstring,
        ipx_b_id: bitstring, ipx_b_key: pubkey
    ));
    if sepp_a_addr' = sepp_a_addr && n32f_cid' = n32f_cid then
    out(n32c, (sepp_b_addr, n32f_cid, ipx_a_id, ipx_a_key));

    (* key derivation *)
    let msg_cnt_a = 0 in
    let master_key_a = deriveMasterKey(n32f_cid, msg_cnt_a) in
    event recvMasterKey(sepp_a_addr, n32f_cid, master_key_a);
    let par_req_key_a = deriveSessionKey(RECV, REQ, master_key_a) in
    let rev_req_key_a = deriveSessionKey(SEND, REQ, master_key_a) in
    let par_res_key_a = deriveSessionKey(RECV, RES, master_key_a) in
    let rev_res_key_a = deriveSessionKey(SEND, RES, master_key_a) in
    let par_req_iv_a = deriveIV(RECV, REQ, master_key_a) in
    let rev_req_iv_a = deriveIV(SEND, REQ, master_key_a) in
    let par_res_iv_a = deriveIV(RECV, RES, master_key_a) in
    let rev_res_iv_a = deriveIV(SEND, RES, master_key_a) in

    (* store session parameters *)
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_cid, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).

let N32cSendErrorSeppA(sepp_a_addr: bitstring)=
    in(err_a, (n32f_context': bitstring, msg_id: nat));
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send error notification *)
    out(n32c, (sepp_b_addr, n32f_context, msg_id));

    (* receive confirmation *)
    in(n32c, (
        sepp_a_addr': bitstring, n32f_context': bitstring, msg_id': nat,
        status_code: bitstring
    ));
    if sepp_a_addr' = sepp_a_addr &&
        n32f_context' = n32f_context &&
        msg_id' = msg_id then
    event errorSignalingSend(sepp_a_addr, n32f_context, msg_id, status_code).

let N32cRecvErrorSeppA(sepp_a_addr: bitstring)=
    in(n32c, (
        sepp_a_addr': bitstring, n32f_context': bitstring, msg_id: nat
    ));
    if sepp_a_addr' = sepp_a_addr then
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* send confirmation *)
    if msg_id <= msg_cnt_a then
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, SUCC));
        event errorSignalingRecv(sepp_a_addr, n32f_context, msg_id, SUCC)
    )
    else
    (
        out(n32c, (sepp_b_addr, n32f_context, msg_id, FAIL));
        event errorSignalingRecv(sepp_a_addr, n32f_context, msg_id, FAIL)
    ).


(* NF B Processes *)

let NfBRequest(nf_b_addr: bitstring, nf_a_addr: bitstring)=
    new msg_body: bitstring;
    let http_message =
        createHttp(nf_b_addr, nf_a_addr, REQ, msg_body) in
    out(plmn_b, http_message);
    event sentHttpMsgNfB(REQ, msg_body).

let NfBResponse(nf_b_addr: bitstring, nf_a_addr: bitstring)=
    in(plmn_b, msg: http);
    let createHttp(nf_a_addr: bitstring,
        nf_b_addr': bitstring,
        msg_type: bitstring,
        msg_body: bitstring) = msg in
    if nf_b_addr' = nf_b_addr then
    (
        if msg_type = REQ then
        (
            event recvHttpMsgNfB(REQ, msg_body);
            out(plmn_b, createHttp(nf_b_addr, nf_a_addr, RES, msg_body));
            event sentHttpMsgNfB(RES, msg_body)
        )
        else
        (
            event recvHttpMsgNfB(RES, msg_body)
        )
    ).

(* SEPP B N32-c Processes *)

let N32cSendHandshakeSeppB(sepp_b_plmn: bitstring, sepp_b_addr: bitstring,
    sepp_a_plmn: bitstring, sepp_a_addr: bitstring, ciphers_b: bitstring,
    encp_b: bitstring, modp_b: bitstring, ipx_b_id: bitstring,
    ipx_b_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    out(n32c, (sepp_a_addr, ciphers_b, n32f_pid));
    in(n32c, (
        sepp_b_addr': bitstring, ciphers_a: bitstring, n32f_pid_a: bitstring
    ));
    if sepp_b_addr' = sepp_b_addr then
    let n32f_cid = deriveContextId(n32f_pid, n32f_pid_a) in
    event sentN32fContext(sepp_b_addr, n32f_pid, n32f_pid_a, n32f_cid);

    (* verify matching encryption policies *)
    out(n32c, (sepp_a_addr, n32f_cid, encp_b, modp_b));
    in(n32c, (sepp_b_addr': bitstring, n32f_cid': bitstring,
        encp_a: bitstring, modp_a: bitstring
    ));
    if sepp_b_addr' = sepp_b_addr &&
        n32f_cid' = n32f_cid &&
        encp_a = encp_b then
    event agreedEncPolicySend(sepp_b_addr, n32f_cid, encp_b);

    (* exchange ipx information *)
    out(n32c, (sepp_a_addr, n32f_cid, ipx_b_id, ipx_b_key));
    in(n32c, (
        sepp_b_addr': bitstring, n32f_cid': bitstring,
        ipx_a_id: bitstring, ipx_a_key: pubkey
    ));

    (* key derivation *)
    if sepp_b_addr' = sepp_b_addr && n32f_cid' = n32f_cid then
    let msg_cnt_b = 0 in
    let master_key_b = deriveMasterKey(n32f_cid, msg_cnt_b) in
    event sentMasterKey(sepp_b_addr, n32f_cid, master_key_b);
    let par_req_key_b = deriveSessionKey(SEND, REQ, master_key_b) in
    let rev_req_key_b = deriveSessionKey(RECV, REQ, master_key_b) in
    let par_res_key_b = deriveSessionKey(SEND, RES, master_key_b) in
    let rev_res_key_b = deriveSessionKey(RECV, RES, master_key_b) in
    let par_req_iv_b = deriveIV(SEND, REQ, master_key_b) in
    let rev_req_iv_b = deriveIV(RECV, REQ, master_key_b) in
    let par_res_iv_b = deriveIV(SEND, RES, master_key_b) in
    let rev_res_iv_b = deriveIV(RECV, RES, master_key_b) in

    (* store session parameters *)
    insert storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_cid, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ).

let N32cRecvHandshakeSeppB(sepp_b_plmn: bitstring, sepp_b_addr: bitstring,
    sepp_a_plmn: bitstring, sepp_a_addr: bitstring, ciphers_b: bitstring,
    encp_b: bitstring, modp_b: bitstring, ipx_b_id: bitstring,
    ipx_b_key: pubkey)=

    (* derive N32-f context id & validate ciphersuites *)
    new n32f_pid: bitstring;
    in(n32c, (
        sepp_b_addr': bitstring, ciphers_a: bitstring,
        n32f_pid_a: bitstring
    ));
    if sepp_b_addr' = sepp_b_addr && ciphers_b = ciphers_a then
    out(n32c, (sepp_a_addr, ciphers_b, n32f_pid));
    let n32f_cid = deriveContextId(n32f_pid_a, n32f_pid) in
    event recvN32fContext(sepp_b_addr, n32f_pid_a, n32f_pid, n32f_cid);

    (* verify matching encryption policies *)
    in(n32c, (sepp_b_addr': bitstring, n32f_cid': bitstring,
        encp_a: bitstring, modp_a: bitstring
    ));
    if sepp_b_addr' = sepp_b_addr &&
        n32f_cid' = n32f_cid &&
        encp_a = encp_b then
    out(n32c, (sepp_a_addr, n32f_cid, encp_b, modp_b));
    event agreedEncPolicyRecv(sepp_b_addr, n32f_cid, encp_b);

    (* exchange ipx information *)
    in(n32c, (
        sepp_b_addr': bitstring, n32f_cid': bitstring,
        ipx_a_id: bitstring, ipx_a_key: pubkey
    ));
    if sepp_b_addr' = sepp_b_addr && n32f_cid' = n32f_cid then
    out(n32c, (sepp_a_addr, n32f_cid, ipx_b_id, ipx_b_key));

    (* key derivation *)
    let msg_cnt_b = 0 in
    let master_key_b = deriveMasterKey(n32f_cid, msg_cnt_b) in
    event recvMasterKey(sepp_b_addr, n32f_cid, master_key_b);
    let par_req_key_b = deriveSessionKey(RECV, REQ, master_key_b) in
    let rev_req_key_b = deriveSessionKey(SEND, REQ, master_key_b) in
    let par_res_key_b = deriveSessionKey(RECV, RES, master_key_b) in
    let rev_res_key_b = deriveSessionKey(SEND, RES, master_key_b) in
    let par_req_iv_b = deriveIV(RECV, REQ, master_key_b) in
    let rev_req_iv_b = deriveIV(SEND, REQ, master_key_b) in
    let par_res_iv_b = deriveIV(RECV, RES, master_key_b) in
    let rev_res_iv_b = deriveIV(SEND, RES, master_key_b) in

    (* store session parameters *)
    insert storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_cid, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ).

let N32cSendErrorSeppB(sepp_b_addr: bitstring)=
    in(err_b, (n32f_context': bitstring, msg_id: nat));
    get storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_context, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) suchthat n32f_context' = n32f_context in

    (* send error notification *)
    out(n32c, (sepp_a_addr, n32f_context, msg_id));

    (* receive confirmation *)
    in(n32c, (
        sepp_b_addr': bitstring, n32f_context': bitstring, msg_id': nat,
        status_code: bitstring
    ));
    if sepp_b_addr' = sepp_b_addr &&
        n32f_context' = n32f_context &&
        msg_id' = msg_id then
    event errorSignalingSend(sepp_b_addr, n32f_context, msg_id, status_code).

let N32cRecvErrorSeppB(sepp_b_addr: bitstring)=
    in(n32c, (
        sepp_b_addr': bitstring, n32f_context': bitstring, msg_id: nat
    ));
    if sepp_b_addr' = sepp_b_addr then
    get storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_context, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) suchthat n32f_context' = n32f_context in

    (* send confirmation *)
    if msg_id <= msg_cnt_b then
    (
        out(n32c, (sepp_a_addr, n32f_context, msg_id, SUCC));
        event errorSignalingRecv(sepp_b_addr, n32f_context, msg_id, SUCC)
    )
    else
    (
        out(n32c, (sepp_a_addr, n32f_context, msg_id, FAIL));
        event errorSignalingRecv(sepp_b_addr, n32f_context, msg_id, FAIL)
    ).


(* SEPP A N32-f Processes *)

let N32fSendSeppA(sepp_b_addr': bitstring)=
    in(plmn_a, http_message: http);
    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat sepp_b_addr' = sepp_b_addr in

    (* rewrite http message *)
    let createHttp(source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        msg_body: bitstring) = http_message in
    event recvHttpMsgSeppA(msg_type, msg_body);
    let conf: bitstring = getConf(msg_body, encp_a) in
    let nonconf: bitstring = getNonconf(msg_body, encp_a) in

    let msg_id: nat = msg_cnt_a + 1 in
    let associated_data = combineAAD(
        source_addr, destination_addr, msg_type,
        nonconf, msg_id, ipx_a_id, n32f_context
    ) in

    (* determine session key & iv *)
    let key = (if msg_type = REQ then
        par_req_key_a else
        par_res_key_a) in
    let nonce = (if msg_type = REQ then
        deriveNonce(par_req_iv_a, msg_id) else
        deriveNonce(par_res_iv_a, msg_id)) in

    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        key,
        nonce,
        conf,
        associated_data
    ) in
    out(n32f_a, (sepp_b_addr, prins'(
        ciphers_a, nonce, associated_data, payload, jwe_tag
    )));
    event sentN32fMsgSeppA(n32f_context, msg_id, conf, nonconf);
    insert storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ).

let N32fRecvSeppA(sepp_a_addr: bitstring)=
    in(n32f_a, (sepp_a_addr': bitstring, prins_messsage: modprins));
    if sepp_a_addr' = sepp_a_addr then

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        nonce: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id: bitstring,
        n32f_context': bitstring
    ) = dataToIntegrityProtect in

    get storeSeppA(
        sepp_b_plmn, sepp_b_addr, n32f_context, msg_cnt_a, par_req_key_a,
        par_res_key_a, rev_req_key_a, rev_res_key_a, par_req_iv_a,
        par_res_iv_a, rev_req_iv_a, rev_res_iv_a, ciphers_a, encp_a,
        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) suchthat n32f_context' = n32f_context in

    (* determine session key & iv *)
    let key = (if msg_type = REQ then
        rev_req_key_a else
        rev_res_key_a) in
    let nonce = (if msg_type = REQ then
        deriveNonce(rev_req_iv_a, msg_id) else
        deriveNonce(rev_res_iv_a, msg_id)) in

    let conf = aeadDecrypt(
        key,
        nonce,
        (dataToIntegrityProtectAndCipher, jwe_tag),
        dataToIntegrityProtect
    ) in
    event recvN32fMsgSeppA(n32f_context', msg_id, conf, nonconf);

    (* verify ipx b json patch *)
    let jsonPatch(
        ipx_b_ops: bitstring,
        ipx_b_id': bitstring,
        jwe_tag_b: mac,
        ipx_b_jws: bitstring
    ) = ipx_b_mods in
    if not(validPrinsSign(ipx_b_jws, ipx_b_key)) ||
        auth_ipx_id <> ipx_b_id' ||
        ipx_b_ops <> modp_b ||
        jwe_tag_b <> jwe_tag
    then
    (
        let valid_patch_b: bool = false in
        out(err_a, (n32f_context, msg_id));
        event recvInvalIpxPatchSeppA(
            auth_ipx_id, n32f_context, jwe_tag, ipx_b_mods
        )
    )
    else
        let valid_patch_b: bool = true in
        event recvValidIpxPatchSeppA(
            auth_ipx_id, n32f_context, jwe_tag, ipx_b_mods
        );

    (* verify ipx a json patch *)
    let jsonPatch(
        ipx_a_ops: bitstring,
        ipx_a_id': bitstring,
        jwe_tag_a: mac,
        ipx_a_jws: bitstring
    ) = ipx_a_mods in
    if not(validPrinsModSign(ipx_a_jws, ipx_a_key)) ||
        ipx_a_id' <> ipx_a_id ||
        ipx_a_ops <> modp_a ||
        jwe_tag_a <> jwe_tag
    then
    (
        let valid_patch_a: bool = false in
        out(err_a, (n32f_context, msg_id));
        event recvInvalIpxPatchSeppA(
            ipx_a_id, n32f_context, jwe_tag, ipx_a_mods
        )
    )
    else
        let valid_patch_a: bool = true in
        event recvValidIpxPatchSeppA(
            ipx_a_id, n32f_context, jwe_tag, ipx_a_mods
        );

    (* all patches valid *)
    if valid_patch_a &&
        valid_patch_b &&
        policyValidation(conf, encp_a) then
    let msg_body = applyPatches((conf, nonconf), ipx_b_ops, ipx_a_ops) in
    let http_message = createHttp(
        source_addr,
        destination_addr,
        msg_type,
        msg_body) in
    out(plmn_a, http_message);
    event sentHttpMsgSeppA(msg_type, msg_body).


(* SEPP B N32-f Processes *)

let N32fSendSeppB(sepp_a_addr': bitstring)=
    in(plmn_b, http_message: http);
    get storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_context, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) suchthat sepp_a_addr' = sepp_a_addr in

    (* rewrite http message *)
    let createHttp(source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        msg_body: bitstring) = http_message in
    event recvHttpMsgSeppB(msg_type, msg_body);
    let conf: bitstring = getConf(msg_body, encp_b) in
    let nonconf: bitstring = getNonconf(msg_body, encp_b) in

    let msg_id: nat = msg_cnt_b + 1 in
    let associated_data = combineAAD(
        source_addr, destination_addr, msg_type,
        nonconf, msg_id, ipx_b_id, n32f_context
    ) in

    (* determine session key & iv *)
    let key = (if msg_type = REQ then
        par_req_key_b else
        par_res_key_b) in
    let nonce = (if msg_type = REQ then
        deriveNonce(par_req_iv_b, msg_id) else
        deriveNonce(par_res_iv_b, msg_id)) in

    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        key,
        nonce,
        conf,
        associated_data
    ) in
    out(n32f_b, (sepp_a_addr, prins'(
        ciphers_b, nonce, associated_data, payload, jwe_tag
    )));
    event sentN32fMsgSeppB(n32f_context, msg_id, conf, nonconf);
    insert storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_context, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ).

let N32fRecvSeppB(sepp_b_addr: bitstring)=
    in(n32f_b, (sepp_b_addr': bitstring, prins_messsage: modprins));
    if sepp_b_addr' = sepp_b_addr then

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        nonce: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_a_mods: ipxmod,
        ipx_b_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id: bitstring,
        n32f_context': bitstring
    ) = dataToIntegrityProtect in

    get storeSeppB(
        sepp_a_plmn, sepp_a_addr, n32f_context, msg_cnt_b, par_req_key_b,
        par_res_key_b, rev_req_key_b, rev_res_key_b, par_req_iv_b,
        par_res_iv_b, rev_req_iv_b, rev_res_iv_b, ciphers_b, encp_b,
        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) suchthat n32f_context' = n32f_context in

    (* determine session key & iv *)
    let key = (if msg_type = REQ then
        rev_req_key_b else
        rev_res_key_b) in
    let nonce = (if msg_type = REQ then
        deriveNonce(rev_req_iv_b, msg_id) else
        deriveNonce(rev_res_iv_b, msg_id)) in

    let conf = aeadDecrypt(
        key,
        nonce,
        (dataToIntegrityProtectAndCipher, jwe_tag),
        dataToIntegrityProtect
    ) in
    event recvN32fMsgSeppB(n32f_context', msg_id, conf, nonconf);

    (* verify ipx a json patch *)
    let jsonPatch(
        ipx_a_ops: bitstring,
        ipx_a_id': bitstring,
        jwe_tag_a: mac,
        ipx_a_jws: bitstring
    ) = ipx_a_mods in
    if not(validPrinsSign(ipx_a_jws, ipx_a_key)) ||
        auth_ipx_id <> ipx_a_id' ||
        ipx_a_ops <> modp_a ||
        jwe_tag_a <> jwe_tag
    then
    (
        let valid_patch_a: bool = false in
        out(err_b, (n32f_context, msg_id));
        event recvInvalIpxPatchSeppB(
            auth_ipx_id, n32f_context, jwe_tag, ipx_a_mods
        )
    )
    else
        let valid_patch_a: bool = true in
        event recvValidIpxPatchSeppB(
            auth_ipx_id, n32f_context, jwe_tag, ipx_a_mods
        );

    (* verify ipx b json patch *)
    let jsonPatch(
        ipx_b_ops: bitstring,
        ipx_b_id': bitstring,
        jwe_tag_b: mac,
        ipx_b_jws: bitstring
    ) = ipx_b_mods in
    if not(validPrinsModSign(ipx_b_jws, ipx_b_key)) ||
        ipx_b_id' <> ipx_b_id ||
        ipx_b_ops <> modp_b ||
        jwe_tag_b <> jwe_tag
    then
    (
        let valid_patch_b: bool = false in
        out(err_b, (n32f_context, msg_id));
        event recvInvalIpxPatchSeppB(
            ipx_b_id, n32f_context, jwe_tag, ipx_b_mods
        )
    )
    else
        let valid_patch_b: bool = true in
        event recvValidIpxPatchSeppB(
            ipx_b_id, n32f_context, jwe_tag, ipx_b_mods
        );

    (* all patches valid *)
    if valid_patch_a &&
        valid_patch_b &&
        policyValidation(conf, encp_b) then
    let msg_body = applyPatches((conf, nonconf), ipx_a_ops, ipx_b_ops) in
    let http_message = createHttp(
        source_addr,
        destination_addr,
        msg_type,
        msg_body) in
    out(plmn_b, http_message);
    event sentHttpMsgSeppB(msg_type, msg_body).


(* IPX A Processes *)

let N32fSendIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_a, (sepp_b_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    out(n32f_i, (sepp_b_addr, modified_message));
    event ipxSendA(n32f_context, jwe_tag, modifications).

let N32fRecvIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    out(n32f_a, (sepp_a_addr, modified_message));
    event ipxRecvA(n32f_context, jwe_tag, modifications).


(* IPX B Processes *)

let N32fSendIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_b, (sepp_a_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    out(n32f_i, (sepp_a_addr, modified_message));
    out(n32f_i, modifications);
    event ipxSendB(n32f_context, jwe_tag, modifications).

let N32fRecvIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_i, (sepp_b_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_a_mods: ipxmod,
        ipx_b_mods: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_a_mods,
        modifications
    ) in
    out(n32f_b, (sepp_b_addr, modified_message));
    event ipxRecvB(n32f_context, jwe_tag, modifications).


(* Rouge IPX Processes *)

(* IPX R1 (Send): applying bogus message modifications *)
(* IPX R1 (Recv): removing previous IPX patch *)

let N32fSendIpxR1(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_a, (sepp_b_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    out(n32f_i, (sepp_b_addr, modified_message));
    event ipxSendR1(n32f_context, jwe_tag, modifications).

let N32fRecvIpxR1(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        EMPTY,
        modifications
    ) in
    out(n32f_a, (sepp_a_addr, modified_message));
    event ipxRecvR1(n32f_context, jwe_tag, modifications).

(* IPX R2 (Send): unknown ipx_id *)
(* IPX R2 (Recv): unknown ipx_id *)

let N32fSendIpxR2(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_a, (sepp_b_addr: bitstring, prins_message: prins));

    (* decompose prins message *)
    let prins'(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        EMPTY
    ) in
    out(n32f_i, (sepp_b_addr, modified_message));
    event ipxSendR2(n32f_context, jwe_tag, modifications).

let N32fRecvIpxR2(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        EMPTY,
        modifications
    ) in
    out(n32f_a, (sepp_a_addr, modified_message));
    event ipxRecvR2(n32f_context, jwe_tag, modifications).


(* IPX R3 (Recv): re-apply foreign ipx patch *)

let N32fRecvIpxR3()=
    in(n32f_i, (sepp_a_addr: bitstring, prins_message: modprins));
    in(n32f_i, modifications: ipxmod);

    (* decompose prins message *)
    let prins''(
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_message in

    (* decompose aad *)
    let combineAAD(
        source_addr: bitstring,
        destination_addr: bitstring,
        msg_type: bitstring,
        nonconf: bitstring,
        msg_id: nat,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    out(n32f_a, (sepp_a_addr, modified_message));
    event ipxRecvR3(n32f_context, jwe_tag, modifications).


(* Main Process *)

process
    (* protection policies *)
    new ciphersuites: bitstring;
    new encp: bitstring;
    new modp_a: bitstring;
    new modp_b: bitstring;
    new modp_r1: bitstring;

    (* participant addresses and ids *)
    new nf_a_addr: bitstring;
    new nf_b_addr: bitstring;
    new sepp_a_plmn: bitstring;
    new sepp_b_plmn: bitstring;
    new sepp_a_addr: bitstring;
    new sepp_b_addr: bitstring;
    new ipx_a_id: bitstring;
    new ipx_b_id: bitstring;
    new ipx_r2_id: bitstring;

    (* sepp cryptographic keys *)
    new sepp_a_privkey: privkey;
    new sepp_b_privkey: privkey;
    let sepp_a_pubkey = pk(sepp_a_privkey) in out(n32f_a, sepp_a_pubkey);
    let sepp_b_pubkey = pk(sepp_b_privkey) in out(n32f_b, sepp_b_pubkey);

    (* ipx cryptographic keys *)
    new ipx_a_privkey: privkey;
    new ipx_b_privkey: privkey;
    new ipx_r2_privkey: privkey;
    let ipx_a_pubkey = pk(ipx_a_privkey) in out(n32f_a, ipx_a_pubkey);
    let ipx_b_pubkey = pk(ipx_b_privkey) in out(n32f_b, ipx_b_pubkey);
    let ipx_r2_pubkey = pk(ipx_r2_privkey) in out(n32f_a, ipx_r2_pubkey);

    (* process execution *)
    (
        (N32cSendHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
        (!N32cRecvHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (N32cSendHandshakeSeppB(
            sepp_b_plmn, sepp_b_addr, sepp_a_plmn, sepp_a_addr,
            ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
        (!N32cRecvHandshakeSeppA(
            sepp_a_plmn, sepp_a_addr, sepp_b_plmn, sepp_b_addr,
            ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
        (phase 1; NfARequest(nf_a_addr, nf_b_addr)) |
        (phase 1; !NfAResponse(nf_a_addr, nf_b_addr)) |
        (phase 1; NfBRequest(nf_b_addr, nf_a_addr)) |
        (phase 1; !NfBResponse(nf_b_addr, nf_a_addr)) |
        (phase 1; !N32fSendSeppA(sepp_b_addr)) |
        (phase 1; !N32fSendSeppB(sepp_a_addr)) |
        (phase 1; !N32fRecvSeppA(sepp_a_addr)) |
        (phase 1; !N32fRecvSeppB(sepp_b_addr)) |
        (phase 1; !N32cSendErrorSeppA(sepp_a_addr)) |
        (phase 1; !N32cRecvErrorSeppA(sepp_a_addr)) |
        (phase 1; !N32cSendErrorSeppB(sepp_b_addr)) |
        (phase 1; !N32cRecvErrorSeppB(sepp_b_addr)) |
        (phase 1; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (phase 1; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
        (phase 1; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (phase 1; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
        (phase 1; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
        (phase 1; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
        (phase 1; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (phase 1; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
        (phase 1; !N32fRecvIpxR3())
    )
