(* custom types *)

type key.                           (* symmetric key *)
type mac.                           (* message authentication code *)
type http.                          (* http message *)
type privkey.                       (* asymmetric privat key *)
type pubkey.                        (* asymmetric public key *)
type prins.                         (* prins message *)
type modprins.                      (* modified prins message w/ patches *)
type aad.                           (* additional authenticated data *)
type ipxmod.                        (* json patch / ipx modifications *)


(* free names / channels *)

free n32f_ati: channel.             (* Channel between SEPP A and IPX A *)
free n32f_iti: channel.             (* Channel between IPX A and IPX B *)
free n32f_bti: channel.             (* Channel between IPX B and SEPP B *)
free n32c: channel [private].       (* Channel between SEPP A and SEPP B *)
const empty: ipxmod.                (* the empty ipx patch *)

(* tables *)

table localStorageSeppA(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP A modification policy *)
                        bitstring,  (* SEPP B modification policy *)
                        bitstring,  (* IPX A id *)
                        pubkey,     (* IPX A public key *)
                        bitstring,  (* IPX B id *)
                        pubkey).    (* IPX B public key *)

table localStorageSeppB(bitstring,  (* N32-f context id *)
                        key,        (* N32-f session key *)
                        bitstring,  (* IV *)
                        bitstring,  (* JWE Ciphersuite *)
                        bitstring,  (* Data-type encryption policy *)
                        bitstring,  (* SEPP B modification policy *)
                        bitstring,  (* SEPP A modification policy *)
                        bitstring,  (* IPX B id *)
                        pubkey,     (* IPX B public key *)
                        bitstring,  (* IPX A id *)
                        pubkey).    (* IPX A public key *)


(* custom data constructors *)

fun httpMess(bitstring,             (* conf *)
        bitstring): http [data].    (* nonconf *)

fun combineAAD(bitstring,           (* DataToIntegrityProtect *)
        bitstring,                  (* Msg Id *)
        bitstring,                  (* Authorized IPX *)
        bitstring): aad [data].     (* N32f Context Id *)

fun jsonPatch(bitstring,            (* Operations *)
        bitstring,                  (* IPX Id *)
        mac,                        (* JWE Tag *)
        bitstring): ipxmod [data].  (* JWS Signature *)

fun prins'(nat,                     (* Sepp Id to avoid trivial cycles *)
        bitstring,                  (* JWE Headers (Cipher Suites etc.) *)
        bitstring,                  (* Initialization Vector *)
        aad,                        (* DataToIntegrityProtect (AAD) *)
        bitstring,                  (* DataToIntegrityProtectAndCipher (Payload) *)
        mac): prins [data].         (* JWE Tag *)

fun prins''(nat,                    (* Sepp Id to avoid trivial cycles *)
        bitstring,                  (* JWE Headers (Cipher Suites etc.) *)
        bitstring,                  (* Initialization Vector *)
        aad,                        (* DataToIntegrityProtect (AAD) *)
        bitstring,                  (* DataToIntegrityProtectAndCipher (Payload) *)
        mac,                        (* JWE Tag *)
        ipxmod,                     (* IPX A Patch *)
        ipxmod): modprins [data].   (* IPX B Patch *)


(* custom functions *)

fun createContextId(bitstring, bitstring): bitstring.
fun deriveMasterKey(bitstring): key [private].
fun deriveSessionKey(key): key.
fun deriveIV(key): bitstring.

(* mac *)
fun macf(bitstring, key): mac.

(* signatures *)
fun pk(privkey): pubkey.
fun sign(bitstring, privkey): bitstring.
reduc forall m: bitstring, k: privkey; getMess(sign(m, k)) = m.
reduc forall m: bitstring, k: privkey; checkSign(sign(m, k), pk(k)) = true.

fun signPrins(prins, bitstring, bitstring, mac, privkey): bitstring.
reduc forall p: prins, ops: bitstring, id: bitstring, tag: mac, k: privkey;
    checkPrinsSign(signPrins(p, ops, id, tag, k), pk(k)) = true.
fun signPrinsMod(modprins, bitstring, bitstring, mac, privkey): bitstring.
reduc forall p: modprins, ops: bitstring, id: bitstring, tag: mac, k: privkey;
    checkPrinsModSign(signPrinsMod(p, ops, id, tag, k), pk(k)) = true.

(* aead encryption *)
fun encrypt(bitstring, key, bitstring): bitstring.
reduc forall msg: bitstring, k: key, iv: bitstring;
    decrypt(encrypt(msg, k, iv), k, iv) = msg.

reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadEncrypt(k, iv, payload, adata) = (
                                encrypt(payload, k, iv),
                                macf((iv, adata, encrypt(payload, k, iv)), k)
                                ).
reduc forall k: key, iv: bitstring, payload: bitstring, adata: aad;
    aeadDecrypt(k,
                iv,
                (encrypt(payload, k, iv), macf((iv, adata, encrypt(payload, k, iv)), k)), adata
                ) = payload.


(* event definitions *)

event agreedContextSendSeppA(bitstring).
event agreedContextRecvSeppA(bitstring).
event agreedContextSendSeppB(bitstring).
event agreedContextRecvSeppB(bitstring).
event agreedEncPolicySendSeppA(bitstring, bitstring).
event agreedEncPolicyRecvSeppA(bitstring, bitstring).
event agreedEncPolicySendSeppB(bitstring, bitstring).
event agreedEncPolicyRecvSeppB(bitstring, bitstring).
event agreedMasterKeySendSeppA(bitstring, key).
event agreedMasterKeyRecvSeppA(bitstring, key).
event agreedMasterKeySendSeppB(bitstring, key).
event agreedMasterKeyRecvSeppB(bitstring, key).

event sendSeppA(bitstring, mac, bitstring, bitstring).
event recvSeppA(bitstring, mac, bitstring, bitstring).
event sendSeppB(bitstring, mac, bitstring, bitstring).
event recvSeppB(bitstring, mac, bitstring, bitstring).

event recvAvalidIpxPatchA(bitstring, mac, ipxmod).
event recvAvalidIpxPatchB(bitstring, mac, ipxmod).
event recvBvalidIpxPatchA(bitstring, mac, ipxmod).
event recvBvalidIpxPatchB(bitstring, mac, ipxmod).
event recvAinvalIpxPatchA().
event recvAinvalIpxPatchB().
event recvBinvalIpxPatchA().
event recvBinvalIpxPatchB().

event sendKeyUpdateSeppA(bitstring, key).
event recvKeyUpdateSeppA(bitstring, key).
event sendKeyUpdateSeppB(bitstring, key).
event recvKeyUpdateSeppB(bitstring, key).

event ipxRecvA(bitstring, mac, ipxmod).
event ipxSendA(bitstring, mac, ipxmod).
event ipxRecvB(bitstring, mac, ipxmod).
event ipxSendB(bitstring, mac, ipxmod).
event ipxRecvR1(bitstring, mac, ipxmod).
event ipxSendR1(bitstring, mac, ipxmod).
event ipxRecvR2(bitstring, mac, ipxmod).
event ipxSendR2(bitstring, mac, ipxmod).


(* secrecy queries *)

free master_key_a, master_key_b, session_key_a, session_key_b: key [private].
free conf: bitstring [private].

query attacker(master_key_a);
      attacker(master_key_b).
query attacker(session_key_a);
      attacker(session_key_b).

(* sec property 7: message confidentiality protection *)
query attacker(conf).

(* sec property 5: strong secrecy of master/session keys *)
noninterf master_key_a.
noninterf master_key_b.
noninterf session_key_a.
noninterf session_key_b.

(* sec property 3: N32-f Context IDs equivalent *)
query n32f_context: bitstring;
    event(agreedContextSendSeppA(n32f_context)) ==>
    inj-event(agreedContextRecvSeppB(n32f_context));
    event(agreedContextSendSeppB(n32f_context)) ==>
    inj-event(agreedContextRecvSeppA(n32f_context)).

(* sec property 4: master keys equivalent *)
query n32f_cid: bitstring, master_key: key;
    event(agreedMasterKeySendSeppA(n32f_cid, master_key)) ==>
    inj-event(agreedMasterKeyRecvSeppB(n32f_cid, master_key));
    event(agreedMasterKeySendSeppB(n32f_cid, master_key)) ==>
    inj-event(agreedMasterKeyRecvSeppA(n32f_cid, master_key)).

(* sec property 6/7/11: integrity protection / authentication *)
query n32f_context: bitstring, jwe_tag: mac, msg_conf: bitstring, msg_nonconf: bitstring;
    event(recvSeppA(n32f_context, jwe_tag, msg_conf, msg_nonconf)) ==>
    inj-event(sendSeppB(n32f_context, jwe_tag, msg_conf, msg_nonconf));
    event(recvSeppB(n32f_context, jwe_tag, msg_conf, msg_nonconf)) ==>
    inj-event(sendSeppA(n32f_context, jwe_tag, msg_conf, msg_nonconf)).

(* sec property 9: json patch authentication/integrity protection *)
query n32f_context: bitstring, jwe_tag: mac, ipx_a_mods: ipxmod, ipx_b_mods: ipxmod;
    event(recvAvalidIpxPatchA(n32f_context, jwe_tag, ipx_a_mods)) ==>
    (inj-event(recvAvalidIpxPatchB(n32f_context, jwe_tag, ipx_b_mods)) ==>
    (inj-event(ipxRecvA(n32f_context, jwe_tag, ipx_a_mods)) ==>
    inj-event(ipxSendB(n32f_context, jwe_tag, ipx_b_mods))));

    event(recvBvalidIpxPatchB(n32f_context, jwe_tag, ipx_b_mods)) ==>
    (inj-event(recvBvalidIpxPatchA(n32f_context, jwe_tag, ipx_a_mods)) ==>
    (inj-event(ipxRecvB(n32f_context, jwe_tag, ipx_b_mods)) ==>
    inj-event(ipxSendA(n32f_context, jwe_tag, ipx_a_mods)))).

(* sec property 12: no unknown ipx providers *)
query n32f_context: bitstring, jwe_tag: mac, ipx_a_mods: ipxmod;
    event(recvAvalidIpxPatchA(n32f_context, jwe_tag, ipx_a_mods)) &&
    event(ipxRecvR2(n32f_context, jwe_tag, ipx_a_mods));

    event(recvBvalidIpxPatchA(n32f_context, jwe_tag, ipx_a_mods)) &&
    event(ipxSendR2(n32f_context, jwe_tag, ipx_a_mods)).

(* sec property 13: unreferenced message modifications *)
query n32f_context: bitstring, jwe_tag: mac, ipx_mods: ipxmod;
    event(recvAvalidIpxPatchA(n32f_context, jwe_tag, ipx_mods)) &&
    event(ipxRecvR1(n32f_context, jwe_tag, ipx_mods));

    event(recvBvalidIpxPatchA(n32f_context, jwe_tag, ipx_mods)) &&
    event(ipxSendR1(n32f_context, jwe_tag, ipx_mods)).

(* sec property 8: removing previous message modifications *)
query n32f_context: bitstring, jwe_tag: mac, ipx_a_mods: ipxmod, ipx_b_mods: ipxmod;
    event(recvAvalidIpxPatchB(n32f_context, jwe_tag, ipx_b_mods)) &&
    event(ipxRecvR1(n32f_context, jwe_tag, ipx_a_mods)).


(* SEPP A N32-c Processes *)

let N32cSendHandshakeSeppA(sepp_a_id: nat, sepp_a_privkey: privkey,
                        cipher_suite: bitstring, encp: bitstring, modp: bitstring,
                        ipx_a_id: bitstring, ipx_a_key: pubkey)=
    new n32f_pid: bitstring;
    new nonce: bitstring;
    let sig = sign(nonce, sepp_a_privkey) in
    out(n32c, (cipher_suite, n32f_pid, nonce, sig, sepp_a_id));
    in(n32c, (cipher_suite_b: bitstring, n32f_pid_b: bitstring, sepp_b_id: nat));
    if sepp_b_id <> sepp_a_id && cipher_suite = cipher_suite_b then
        let n32f_cid = createContextId(n32f_pid, n32f_pid_b) in
        event agreedContextSendSeppA(n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicySendSeppA(n32f_cid, encp);
            out(n32c, (ipx_a_id, ipx_a_key));
            in(n32c, (ipx_b_id: bitstring, ipx_b_key: pubkey));
            let master_key_a = deriveMasterKey(nonce) in
            event agreedMasterKeySendSeppA(n32f_cid, master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key).

let N32cRecvHandshakeSeppA(sepp_a_id: nat, sepp_b_pubkey: pubkey,
                        cipher_suite: bitstring, encp: bitstring, modp: bitstring,
                        ipx_a_id: bitstring, ipx_a_key: pubkey)=
    new n32f_pid: bitstring;
    in(n32c, (cipher_suite_b: bitstring, n32f_pid_b: bitstring,
            nonce: bitstring, sig: bitstring, sepp_b_id: nat));
    if sepp_b_id <> sepp_a_id &&
       checkSign(sig, sepp_b_pubkey) &&
       cipher_suite = cipher_suite_b then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_b, n32f_pid) in
        event agreedContextRecvSeppA(n32f_cid);
        in(n32c, (encp_b: bitstring, modp_b: bitstring));
        if encp_b = encp then
            event agreedEncPolicyRecvSeppA(n32f_cid, encp);
            out(n32c, (encp, modp));
            in(n32c, (ipx_b_id: bitstring, ipx_b_key: pubkey));
            out(n32c, (ipx_a_id, ipx_a_key));
            let master_key_a = deriveMasterKey(nonce) in
            event agreedMasterKeyRecvSeppA(n32f_cid, master_key_a);
            let session_key_a = deriveSessionKey(master_key_a) in
            insert localStorageSeppA(n32f_cid, session_key_a,
                                    deriveIV(master_key_a), cipher_suite, encp,
                                    modp, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key).

let N32cSendKeyUpdateSeppA(sepp_a_id: nat, sepp_a_privkey: privkey)=
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    new nonce: bitstring;
    let sig = sign(nonce, sepp_a_privkey) in
    out(n32c, (nonce, sig, sepp_a_id));
    let master_key_a = deriveMasterKey(nonce) in
    let session_key_a = deriveSessionKey(master_key_a) in
    insert localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    );
    event sendKeyUpdateSeppA(nonce, master_key_a).

let N32cRecvKeyUpdateSeppA(sepp_a_id: nat, sepp_b_pubkey: pubkey)=
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    in(n32c, (nonce: bitstring, sig: bitstring, sepp_b_id: nat));
    if sepp_b_id <> sepp_a_id && checkSign(sig, sepp_b_pubkey) then
    let master_key_a = deriveMasterKey(nonce) in
    let session_key_a = deriveSessionKey(master_key_a) in
    insert localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    );
    event recvKeyUpdateSeppA(nonce, master_key_a).


(* SEPP B N32-c Processes *)

let N32cSendHandshakeSeppB(sepp_b_id: nat, sepp_b_privkey: privkey,
                        cipher_suite: bitstring, encp: bitstring, modp: bitstring,
                        ipx_b_id: bitstring, ipx_b_key: pubkey)=
    new n32f_pid: bitstring;
    new nonce: bitstring;
    let sig = sign(nonce, sepp_b_privkey) in
    out(n32c, (cipher_suite, n32f_pid, nonce, sig, sepp_b_id));
    in(n32c, (cipher_suite_a: bitstring, n32f_pid_a: bitstring, sepp_a_id: nat));
    if sepp_a_id <> sepp_b_id && cipher_suite = cipher_suite_a then
        let n32f_cid = createContextId(n32f_pid, n32f_pid_a) in
        event agreedContextSendSeppB(n32f_cid);
        out(n32c, (encp, modp));
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicySendSeppB(n32f_cid, encp);
            out(n32c, (ipx_b_id, ipx_b_key));
            in(n32c, (ipx_a_id: bitstring, ipx_a_key: pubkey));
            let master_key_b = deriveMasterKey(nonce) in
            event agreedMasterKeySendSeppB(n32f_cid, master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key).

let N32cRecvHandshakeSeppB(sepp_b_id: nat, sepp_a_pubkey: pubkey,
                        cipher_suite: bitstring, encp: bitstring, modp: bitstring,
                        ipx_b_id: bitstring, ipx_b_key: pubkey)=
    new n32f_pid: bitstring;
    in(n32c, (cipher_suite_a: bitstring, n32f_pid_a: bitstring,
            nonce: bitstring, sig: bitstring, sepp_a_id: nat));
    if sepp_a_id <> sepp_b_id &&
       checkSign(sig, sepp_a_pubkey) &&
       cipher_suite = cipher_suite_a then
        out(n32c, (cipher_suite, n32f_pid));
        let n32f_cid = createContextId(n32f_pid_a, n32f_pid) in
        event agreedContextRecvSeppB(n32f_cid);
        in(n32c, (encp_a: bitstring, modp_a: bitstring));
        if encp_a = encp then
            event agreedEncPolicyRecvSeppB(n32f_cid, encp);
            out(n32c, (encp, modp));
            in(n32c, (ipx_a_id: bitstring, ipx_a_key: pubkey));
            out(n32c, (ipx_b_id, ipx_b_key));
            let master_key_b = deriveMasterKey(nonce) in
            event agreedMasterKeyRecvSeppB(n32f_cid, master_key_b);
            let session_key_b = deriveSessionKey(master_key_b) in
            insert localStorageSeppB(n32f_cid, session_key_b,
                                    deriveIV(master_key_b), cipher_suite, encp,
                                    modp, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key).

let N32cSendKeyUpdateSeppB(sepp_b_id: nat, sepp_b_privkey: privkey)=
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    new nonce: bitstring;
    let sig = sign(nonce, sepp_b_privkey) in
    out(n32c, (nonce, sig, sepp_b_id));
    let master_key_b = deriveMasterKey(nonce) in
    let session_key_b = deriveSessionKey(master_key_b) in
    insert localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    );
    event sendKeyUpdateSeppB(nonce, master_key_b).

let N32cRecvKeyUpdateSeppB(sepp_b_id: nat, sepp_a_pubkey: pubkey)=
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    in(n32c, (nonce: bitstring, sig: bitstring, sepp_a_id: nat));
    if sepp_a_id <> sepp_b_id && checkSign(sig, sepp_a_pubkey) then
    let master_key_b = deriveMasterKey(nonce) in
    let session_key_b = deriveSessionKey(master_key_b) in
    insert localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    );
    event recvKeyUpdateSeppB(nonce, master_key_b).


(* SEPP A N32-f Processes *)

let N32fSendSeppA(sepp_a_id: nat)=
    new msg_id: bitstring;
    new msg: http;
    let httpMess(conf, nonconf) = msg in
    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    let associated_data = combineAAD(nonconf, msg_id, ipx_a_id, n32f_context) in
    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        session_key_a,
        iv,
        conf,
        associated_data
    ) in
    out(n32f_ati, prins'(sepp_a_id, cipher_suite, iv, associated_data, payload, jwe_tag));
    event sendSeppA(n32f_context, jwe_tag, conf, nonconf).

let N32fRecvSeppA(sepp_a_id: nat)=
    in(n32f_ati, prins_messsage: modprins);

    (* decompose prins message *)
    let prins''(sepp_b_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        ipx_a_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id: bitstring,
        n32f_cid_b: bitstring
    ) = dataToIntegrityProtect in

    get localStorageSeppA(n32f_context, session_key_a, iv, cipher_suite, encp,
                        modp_a, modp_b, ipx_a_id, ipx_a_key, ipx_b_id, ipx_b_key
    ) in
    (* verify same n32f context and different sepp, then decrypt *)
    if n32f_cid_b = n32f_context && sepp_b_id <> sepp_a_id then
        let conf = aeadDecrypt(
            session_key_a,
            iv,
            dataToIntegrityProtectAndCipher,
            dataToIntegrityProtect
        ) in

        (* verify ipx b json patch *)
        let jsonPatch(
            ipx_b_ops: bitstring,
            ipx_b_id': bitstring,
            jwe_tag_b: mac,
            ipx_b_jws: bitstring
        ) = ipx_b_mods in
        if checkPrinsSign(ipx_b_jws, ipx_b_key) &&
            auth_ipx_id = ipx_b_id' &&
            ipx_b_ops = modp_b &&
            jwe_tag_b = jwe_tag
        then
            let valid_patch_b: bool = true in
            event recvAvalidIpxPatchB(n32f_context, jwe_tag, ipx_b_mods)
        else
            let valid_patch_b: bool = false in
            event recvAinvalIpxPatchB();

        (* verify ipx a json patch *)
        let jsonPatch(
            ipx_a_ops: bitstring,
            ipx_a_id': bitstring,
            jwe_tag_a: mac,
            ipx_a_jws: bitstring
        ) = ipx_a_mods in
        if checkPrinsModSign(ipx_a_jws, ipx_a_key) &&
            ipx_a_id = ipx_a_id' &&
            ipx_a_ops = modp_a &&
            jwe_tag_a = jwe_tag
        then
            let valid_patch_a: bool = true in
            event recvAvalidIpxPatchA(n32f_context, jwe_tag, ipx_a_mods)
        else
            let valid_patch_a: bool = false in
            event recvAinvalIpxPatchA();

        (* all patches valid *)
        if valid_patch_a && valid_patch_b then
        event recvSeppA(n32f_context, jwe_tag, conf, nonconf).


(* SEPP B N32-f Processes *)

let N32fSendSeppB(sepp_b_id: nat)=
    new msg_id: bitstring;
    new msg: http;
    let httpMess(conf, nonconf) = msg in
    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    let associated_data = combineAAD(nonconf, msg_id, ipx_b_id, n32f_context) in
    let (payload: bitstring, jwe_tag: mac) = aeadEncrypt(
        session_key_b,
        iv,
        conf,
        associated_data
    ) in
    out(n32f_bti, prins'(sepp_b_id, cipher_suite, iv, associated_data, payload, jwe_tag));
    event sendSeppB(n32f_context, jwe_tag, conf, nonconf).

let N32fRecvSeppB(sepp_b_id: nat)=
    in(n32f_bti, prins_messsage: modprins);

    (* decompose prins message *)
    let prins''(sepp_a_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_a_mods: ipxmod,
        ipx_b_mods: ipxmod
    ) = prins_messsage in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id: bitstring,
        n32f_cid_a: bitstring
    ) = dataToIntegrityProtect in

    get localStorageSeppB(n32f_context, session_key_b, iv, cipher_suite, encp,
                        modp_b, modp_a, ipx_b_id, ipx_b_key, ipx_a_id, ipx_a_key
    ) in
    (* verify same n32f context and different sepp, then decrypt *)
    if n32f_cid_a = n32f_context && sepp_a_id <> sepp_b_id then
        let conf = aeadDecrypt(
            session_key_b,
            iv,
            dataToIntegrityProtectAndCipher,
            dataToIntegrityProtect
        ) in

        (* verify ipx a json patch *)
        let jsonPatch(
            ipx_a_ops: bitstring,
            ipx_a_id': bitstring,
            jwe_tag_a: mac,
            ipx_a_jws: bitstring
        ) = ipx_a_mods in
        if checkPrinsSign(ipx_a_jws, ipx_a_key) &&
            auth_ipx_id = ipx_a_id' &&
            ipx_a_ops = modp_a &&
            jwe_tag_a = jwe_tag
        then
            let valid_patch_a: bool = true in
            event recvBvalidIpxPatchA(n32f_context, jwe_tag, ipx_a_mods)
        else
            let valid_patch_a: bool = false in
            event recvBinvalIpxPatchA();

        (* verify ipx b json patch *)
        let jsonPatch(
            ipx_b_ops: bitstring,
            ipx_b_id': bitstring,
            jwe_tag_b: mac,
            ipx_b_jws: bitstring
        ) = ipx_b_mods in
        if checkPrinsModSign(ipx_b_jws, ipx_b_key) &&
            ipx_b_id' = ipx_b_id &&
            ipx_b_ops = modp_b &&
            jwe_tag_b = jwe_tag
        then
            let valid_patch_b: bool = true in
            event recvBvalidIpxPatchB(n32f_context, jwe_tag, ipx_b_mods)
        else
            let valid_patch_b: bool = false in
            event recvBinvalIpxPatchB();

        (* all patches valid *)
        if valid_patch_a && valid_patch_b then
        event recvSeppB(n32f_context, jwe_tag, conf, nonconf).


(* IPX A Processes *)

let N32fSendIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_ati, (prins_message: prins));

    (* decompose prins message *)
    let prins'(sepp_a_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
                sepp_a_id,
                jwe_headers,
                iv,
                dataToIntegrityProtect,
                dataToIntegrityProtectAndCipher,
                jwe_tag,
                modifications,
                empty
    ) in
    out(n32f_iti, modified_message);
    event ipxSendA(n32f_context, jwe_tag, modifications).

let N32fRecvIpxA(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        sepp_b_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        empty: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id : bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        sepp_b_id,
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_b_mods,
        modifications
    ) in
    out(n32f_ati, modified_message);
    event ipxRecvA(n32f_context, jwe_tag, modifications).


(* IPX B Processes *)

let N32fSendIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_bti, (prins_message: prins));

    (* decompose prins message *)
    let prins'(
        sepp_b_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        sepp_b_id,
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        modifications,
        empty
    ) in
    out(n32f_iti, modified_message);
    event ipxSendB(n32f_context, jwe_tag, modifications).

let N32fRecvIpxB(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        sepp_a_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_a_mods: ipxmod,
        empty: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id : bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        sepp_a_id,
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        ipx_a_mods,
        modifications
    ) in
    out(n32f_bti, modified_message);
    event ipxRecvB(n32f_context, jwe_tag, modifications).


(* Rouge IPX Processes *)

(* IPX R1 (Send): applying bogus message modifications *)
(* IPX R1 (Recv): removing previous IPX patch *)

let N32fSendIpxR1(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_ati, (prins_message: prins));

    (* decompose prins message *)
    let prins'(sepp_a_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
                sepp_a_id,
                jwe_headers,
                iv,
                dataToIntegrityProtect,
                dataToIntegrityProtectAndCipher,
                jwe_tag,
                modifications,
                empty
    ) in
    out(n32f_iti, modified_message);
    event ipxSendR1(n32f_context, jwe_tag, modifications).

let N32fRecvIpxR1(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        sepp_b_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        empty: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id : bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        sepp_b_id,
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        empty,
        modifications
    ) in
    out(n32f_ati, modified_message);
    event ipxRecvR1(n32f_context, jwe_tag, modifications).

(* IPX R2 (Send): unknown ipx_id *)
(* IPX R2 (Recv): unknown ipx_id *)

let N32fSendIpxR2(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_ati, (prins_message: prins));

    (* decompose prins message *)
    let prins'(sepp_a_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrins(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id: bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
                sepp_a_id,
                jwe_headers,
                iv,
                dataToIntegrityProtect,
                dataToIntegrityProtectAndCipher,
                jwe_tag,
                modifications,
                empty
    ) in
    out(n32f_iti, modified_message);
    event ipxSendR2(n32f_context, jwe_tag, modifications).

let N32fRecvIpxR2(id: bitstring, privkey: privkey, ops: bitstring)=
    in(n32f_iti, (prins_message: modprins));

    (* decompose prins message *)
    let prins''(
        sepp_b_id: nat,
        jwe_headers: bitstring,
        iv: bitstring,
        dataToIntegrityProtect: aad,
        dataToIntegrityProtectAndCipher: bitstring,
        jwe_tag: mac,
        ipx_b_mods: ipxmod,
        empty: ipxmod
    ) = prins_message in

    (* compose ipx patch *)
    let modifications = jsonPatch(ops, id, jwe_tag,
                        signPrinsMod(prins_message, ops, id, jwe_tag, privkey)
    ) in

    (* decompose aad *)
    let combineAAD(
        nonconf: bitstring,
        msg_id : bitstring,
        auth_ipx_id : bitstring,
        n32f_context: bitstring
    ) = dataToIntegrityProtect in

    (* compose modified message *)
    let modified_message = prins''(
        sepp_b_id,
        jwe_headers,
        iv,
        dataToIntegrityProtect,
        dataToIntegrityProtectAndCipher,
        jwe_tag,
        empty,
        modifications
    ) in
    out(n32f_ati, modified_message);
    event ipxRecvR2(n32f_context, jwe_tag, modifications).


(* Main Process *)

process
    (* jwe ciphersuite *)
    new ciphersuites: bitstring;

    (* protection policies *)
    new encp: bitstring;
    new modp_a: bitstring;
    new modp_b: bitstring;
    new modp_r1: bitstring;

    (* ipx ids *)
    new ipx_a_id: bitstring;
    new ipx_b_id: bitstring;
    new ipx_r2_id: bitstring;

    (* sepp cryptographic keys *)
    new sepp_a_privkey: privkey;
    new sepp_b_privkey: privkey;
    let sepp_a_pubkey = pk(sepp_a_privkey) in out(n32f_ati, sepp_a_pubkey);
    let sepp_b_pubkey = pk(sepp_b_privkey) in out(n32f_bti, sepp_b_pubkey);

    (* ipx cryptographic keys *)
    new ipx_a_privkey: privkey;
    new ipx_b_privkey: privkey;
    new ipx_r2_privkey: privkey;
    let ipx_a_pubkey = pk(ipx_a_privkey) in out(n32f_ati, ipx_a_pubkey);
    let ipx_b_pubkey = pk(ipx_b_privkey) in out(n32f_bti, ipx_b_pubkey);
    let ipx_r2_pubkey = pk(ipx_r2_privkey) in out(n32f_ati, ipx_r2_pubkey);

    (* process execution *)
    ((!N32cSendHandshakeSeppA(0, sepp_a_privkey, ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
    (!N32cRecvHandshakeSeppA(0, sepp_b_pubkey, ciphersuites, encp, modp_a, ipx_a_id, ipx_a_pubkey)) |
    (!N32cSendHandshakeSeppB(1, sepp_b_privkey, ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
    (!N32cRecvHandshakeSeppB(1, sepp_a_pubkey, ciphersuites, encp, modp_b, ipx_b_id, ipx_b_pubkey)) |
    (sync 1; !N32fSendSeppA(0)) |
    (sync 1; !N32fSendSeppB(1)) |
    (sync 1; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (sync 1; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (sync 1; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (sync 1; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (sync 1; !N32fRecvIpxR1(ipx_a_id, ipx_a_privkey, modp_a)) |
    (sync 1; !N32fSendIpxR1(ipx_a_id, ipx_a_privkey, modp_r1)) |
    (sync 1; !N32fRecvIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
    (sync 1; !N32fSendIpxR2(ipx_r2_id, ipx_r2_privkey, modp_a)) |
    (sync 1; !N32fRecvSeppA(0)) |
    (sync 1; !N32fRecvSeppB(1)) |
    (sync 2; !N32cSendKeyUpdateSeppA(0, sepp_a_privkey)) |
    (sync 2; !N32cRecvKeyUpdateSeppA(0, sepp_b_pubkey)) |
    (sync 2; !N32cSendKeyUpdateSeppB(1, sepp_b_privkey)) |
    (sync 2; !N32cRecvKeyUpdateSeppB(1, sepp_a_pubkey)) |
    (sync 3; !N32fSendSeppA(0)) |
    (sync 3; !N32fSendSeppB(1)) |
    (sync 3; !N32fRecvIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (sync 3; !N32fSendIpxA(ipx_a_id, ipx_a_privkey, modp_a)) |
    (sync 3; !N32fRecvIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (sync 3; !N32fSendIpxB(ipx_b_id, ipx_b_privkey, modp_b)) |
    (sync 3; !N32fRecvSeppA(0)) |
    (sync 3; !N32fRecvSeppB(1)))